<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>桂圆的第二人生 on 桂圆的第二人生 </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>https://guixiaoyuan.github.io/</link>
    <language>en-us</language>
    <author>Xiaoyuan Gui</author>
    <copyright>Copyright (c) 2017, Xiaoyuan Gui; all rights reserved.</copyright>
    <updated>Tue, 02 Jun 2020 00:00:00 UTC</updated>
    
    <item>
      <title>android冷启动小研究</title>
<<<<<<< HEAD
      <link>https://guixiaoyuan.github.io/post/2020-06-02/</link>
      <pubDate>Tue, 02 Jun 2020 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2020-06-02/</guid>
=======
      <link>https://guixiaoyuan.github.io/post/2018-11-08/</link>
      <pubDate>Tue, 02 Jun 2020 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2018-11-08/</guid>
>>>>>>> ae597b3bc1c793d5a6f498a7653425393bbc5392
      <description>&lt;p&gt;随着项目版本的迭代，App的性能问题会逐渐暴露出来，而好的用户体验与性能表现紧密相关。来看一下Google官方文档&lt;a href=&#34;https://developer.android.com/topic/performance/launch-time.html&#34;&gt;《Launch-Time Performance》&lt;/a&gt; 对应用启动优化的概述；
&lt;/p&gt;

&lt;h2 id=&#34;冷启动&#34;&gt;冷启动&lt;/h2&gt;

&lt;p&gt;当后台不存在该应用的任何进程或者服务时，用户点击icon图标启动，我们称之为冷启动。&lt;/p&gt;

&lt;h2 id=&#34;热启动&#34;&gt;热启动&lt;/h2&gt;

&lt;p&gt;当后台存在该应用的进程或者服务时，用户点击icon图标启动，我们称之为热启动。
一般是用户按了home键回到桌面，或者返回键没有杀进程，或者app本身做了进程重启的机制。&lt;/p&gt;

&lt;h2 id=&#34;温启动&#34;&gt;温启动&lt;/h2&gt;

&lt;p&gt;当启动应用时，后台已有该应用的进程，但是启动的入口Activity被干掉了，比如按了back键，应用虽然退出了，但是该应用的进程是依然会保留在后台。&lt;/p&gt;

&lt;h2 id=&#34;启动组成时间&#34;&gt;启动组成时间&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;冷启动时间： application初始化时间+欢迎页停留时间&lt;/li&gt;
&lt;li&gt;热启动时间： 欢迎页停留时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用户体验时间：冷启动时间+主界面展示时间&lt;/p&gt;

&lt;p&gt;冷启动执行三个任务：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;加载启动app&lt;/li&gt;
&lt;li&gt;app启动之后立即展示一个空白的window&lt;/li&gt;
&lt;li&gt;创建app的进程&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;点击icon之后，会启动一个ipc，ipc会通知process.start,这个时候会启动activityThread,activityThread是每一个单独进程的入口，相当于入口类,里面有个main方法,里面会消息处理，进行bindApplication,通过反射调用applicaiton，进行application生命周期，后面进行activity的生命周期

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;启动后时间节点&#34;&gt;启动后时间节点&lt;/h3&gt;

&lt;p&gt;Application的构造器方法——&amp;gt;attachBaseContext()——&amp;gt;onCreate()——&amp;gt;Activity的构造方法——&amp;gt;onCreate()——&amp;gt;配置主题中背景等属性——&amp;gt;onStart()——&amp;gt;onResume()——&amp;gt;测量、布局、绘制显示在界面上。&lt;/p&gt;

&lt;h3 id=&#34;application-初始化&#34;&gt;Application 初始化&lt;/h3&gt;

&lt;p&gt;application启动经历两个方法。结束后才会出现lanucher界面。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;attachBaseContext ---&amp;gt; onCreate
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;attachBaseContext 一般不会重写。只有在multiDex，或者一些特殊业务，比如插件化，导致在此方法中执行操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;优化&#34;&gt;优化&lt;/h3&gt;

&lt;p&gt;作为一个用户使用的普通应用，进程级别的操作，我们没有办法进行优化。可以优化的是application,activity的创建和回调。&lt;/p&gt;

&lt;p&gt;google官方给了优化方向：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;利用提前展示出来的Window，快速展示出来一个界面，给用户快速反馈的体验；（这种方法不能提升启动速率，只能使交互好一点）&lt;/li&gt;
&lt;li&gt;避免在启动时做密集沉重的初始化（Heavy app initialization）；&lt;/li&gt;
&lt;li&gt;定位问题：避免I/O操作、反序列化、网络操作、布局嵌套等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;启动加速之avoid-heavy-app-initialization&#34;&gt;启动加速之Avoid Heavy App Initialization&lt;/h4&gt;

&lt;p&gt;在Application以及首屏Activity中我们主要做了：
MultiDex以及Tinker的初始化，最先执行；Application中主要做了各种三方组件的初始化；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;项目中除听云之外其余所有三方组件都抢占先机，在Application主线程初始化。这样的初始化方式肯定是过重的:
考虑异步初始化三方组件，不阻塞主线程；&lt;/li&gt;
&lt;li&gt;延迟部分三方组件的初始化；实际上我们粗粒度的把所有三方组件都放到异步任务里，可能会出现WorkThread中尚未初始化完毕但MainThread中已经使用的错误，因此这种情况建议延迟到使用前再去初始化；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;项目修改：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将友盟、Bugly、听云、GrowingIO、BlockCanary等组件放在WorkThread中初始化；
延迟地图定位、ImageLoader、自有统计等组件的初始化：地图及自有统计延迟4秒，此时应用已经打开；而ImageLoader
因为调用关系不能异步以及过久延迟，初始化从Application延迟到SplashActivity；而EventBus因为再Activity中使用所以必须在Application中初始化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;启动加速之diagnosing-the-problem&#34;&gt;启动加速之Diagnosing The Problem&lt;/h4&gt;

&lt;p&gt;分析到部分耗时操作发生在主线程，那我们把耗时操作都改到子线程是不是就万事大吉了？非也！！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;卡顿不能都靠异步来解决，错误的使用工程线程不仅不能改善卡顿，反而可能加剧卡顿。是否需要开启工作线程需要根据具体的性能瓶颈根源具体分析，对症下药，不可一概而论；&lt;/li&gt;
&lt;li&gt;而如何开启线程同样也有学问：Thread、ThreadPoolExecutor、AsyncTask、HandlerThread、IntentService等都各有利弊；例如通常情况下ThreadPoolExecutor比Thread更加高效、优势明显，但是特定场景下单个时间点的表现Thread会比ThreadPoolExecutor好：同样的创建对象，ThreadPoolExecutor的开销明显比Thread大；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;正确的开启线程也不能包治百病，例如执行网络请求会创建线程池，而在Application中正确的创建线程池势必也会降低启动速度；因此延迟操作也必不可少。&lt;/p&gt;

&lt;p&gt;通过对traceview的详细跟踪以及代码的详细比对，我发现卡顿发生在：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;部分数据库及IO的操作发生在首屏Activity主线程；&lt;/li&gt;
&lt;li&gt;Application中创建了线程池；&lt;/li&gt;
&lt;li&gt;首屏Activity网络请求密集；&lt;/li&gt;
&lt;li&gt;工作线程使用未设置优先级；&lt;/li&gt;
&lt;li&gt;信息未缓存，重复获取同样信息；&lt;/li&gt;
&lt;li&gt;流程问题：例如闪屏图每次下载，当次使用；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以及其它细节问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;执行无用老代码；&lt;/li&gt;
&lt;li&gt;执行开发阶段使用的代码；&lt;/li&gt;
&lt;li&gt;执行重复逻辑；&lt;/li&gt;
&lt;li&gt;调用三方SDK里或者Demo里的多余代码；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;启动app的launcher activity，计算时间。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adb shell am start -W com.leku.hmsq/com.leku.hmq.activity.WelcomeActivity
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Starting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.leku.hmsq/com.leku.hmq.activity.WelcomeActivity }
Status: ok
Activity: com.leku.hmsq/com.leku.hmq.activity.HomeTabActivity


ThisTime: 629
TotalTime: 738
WaitTime: 755
Complete


ThisTime:最后一个启动的Activity的启动耗时；
TotalTime:自己的所有Activity的启动耗时；
WaitTime: ActivityManagerService启动App的Activity时的总时间（包括当前Activity的onPause()和自己Activity的启动）。

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看每一个activity的显示时间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adb logcat | grep &amp;quot;ActivityManager&amp;quot;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>LeetCode First Problem</title>
      <link>https://guixiaoyuan.github.io/post/2019-06-22/</link>
      <pubDate>Sat, 22 Jun 2019 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2019-06-22/</guid>
      <description>&lt;p&gt;程序 = 算法+数据结构&lt;/p&gt;

&lt;p&gt;编程语言虽然该学，但是学习计算机算法和理论更重要，因为计算机语言和开发平台日新月异，但万变不离其宗的是那些算法和理论，例如数据结构、算法、编译原理、计算机体系结构、关系型数据库原理等等。这些基础课程是“内功”，新的语言、技术、标准是“外功”。整天赶时髦的人最后只懂得招式，没有功力，是不可能成为高手的。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;first-problem&#34;&gt;First problem&lt;/h1&gt;

&lt;h3 id=&#34;explain&#34;&gt;explain:&lt;/h3&gt;

&lt;p&gt;Given nums = [2, 7, 11, 15], target = 9,&lt;/p&gt;

&lt;p&gt;return [0, 1].&lt;/p&gt;

&lt;p&gt;Because nums[0] + nums[1] = 2 + 7 = 9,&lt;/p&gt;

&lt;h3 id=&#34;solution&#34;&gt;solution:&lt;/h3&gt;

&lt;p&gt;我第一个想法是两层循环，去寻找这两个数。&lt;/p&gt;

&lt;p&gt;所以解决方案出来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public int[] twoSum(int[] nums, int target) {
    for (int i = 0; i &amp;lt; nums.length; i++) {
        for (int j = i + 1; j &amp;lt; nums.length; j++) {
            if (nums[j] == target - nums[i]) {
                return new int[] { i, j };
            }
        }
    }
    throw new IllegalArgumentException(&amp;quot;No two sum solution&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这个解决方案，如果考虑到时间复杂度的话，n^2，空间复杂度 1&lt;/p&gt;

&lt;p&gt;leetCode 给了一个降低时间复杂度的方案，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public int[] twoSum(int[] nums, int target) {
    Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
    for (int i = 0; i &amp;lt; nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[] { map.get(complement), i };
        }
        map.put(nums[i], i);
    }
    throw new IllegalArgumentException(&amp;quot;No two sum solution&amp;quot;);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;时间复杂度，n 空间复杂度 1&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>mac连接android手机问题</title>
      <link>https://guixiaoyuan.github.io/post/2018-11-08/</link>
      <pubDate>Thu, 08 Nov 2018 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2018-11-08/</guid>
      <description>&lt;p&gt;笔者的mac，装了&lt;a href=&#34;https://www.android.com/filetransfer/&#34;&gt;Android File Transter&lt;/a&gt;
可以连接国内的华为，小米，魅族之类的手机。&lt;/p&gt;

&lt;p&gt;但是比如vivo系列，oppo系列就无法连接。这个时候需要手动添加设备id，识别。
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;打开终端，输入：system_profiler SPUSBDataType，查看Mac系统所有USB设备信息，找到相应的厂商Vender ID。&lt;/p&gt;

&lt;p&gt;查到相应连有Android手机设备的usb hub，找到相应的厂商Vender ID,比如，我的测试机oppo语手机就无法连接adb，查到的相应信息片段如下：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;OPPO:

              Product ID: 0x2773
              Vendor ID: 0x22d9
              Version: ff.ff
              Serial Number: K7RK5DDANVAYE6Y5
              Speed: Up to 480 Mb/sec
              Manufacturer: MediaTek
              Location ID: 0x14610000 / 46
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;终端进入/Users/user/.android，应该有一个adb_usb.ini文件，如果没有就创建，然后将上面的Vender ID “0x22d9”单独一行加入到该文件，然后退出。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重启adb server进程。&lt;/p&gt;

&lt;p&gt;adb kill-server
adb start-server&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ps&#34;&gt;PS：&lt;/h3&gt;

&lt;p&gt;有时 adb devices不能显示连接设备，需要拔掉数据线，多插几次，并且退出终端，然后重新打开，再输入命令就能发现连接的设备，再无法连接请重启电脑，等待系统初始化环境设置。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于Andorid内存泄漏</title>
      <link>https://guixiaoyuan.github.io/post/2018-10-23/</link>
      <pubDate>Tue, 23 Oct 2018 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2018-10-23/</guid>
      <description>&lt;p&gt;OOM问题会经常困扰我们，尤其是维护一个用户数量基数大的app的时候，我们的bug统计数据前几位，基本上会被OOM问题给占据。通过结果反向分析问题，和在写代码的时候注意内存泄漏从而避免OOM，本质上都需要对内存泄漏的产生，以及几种常见的方式需要有着清晰的认识。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;内存泄漏的根本原因&#34;&gt;内存泄漏的根本原因：&lt;/h1&gt;

&lt;p&gt;长生命周期的对象 持有 短生命周期 的强/弱引用，导致本应该被回收的短生命周期的对象无法被正常回收。&lt;/p&gt;

&lt;h1 id=&#34;内存泄漏的情况&#34;&gt;内存泄漏的情况&lt;/h1&gt;

&lt;h2 id=&#34;单例模式&#34;&gt;单例模式&lt;/h2&gt;

&lt;p&gt;由于单例模式的静态特性，使得它的生命周期和我们的应用一样长，一不小心让单例无限制的持有 Activity 的强引用就会导致内存泄漏。&lt;/p&gt;

&lt;p&gt;解决办法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class BaseApplication extends Application{
    private static ApplicationContext sContext;
    @Override
    public void onCreate(){
        super.onCreate();
        //全局的context，不再使用activity的引用
        sContext = getApplicationContext();
    }
    public static Context getApplicationContext(){
        return sContext;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;handler使用&#34;&gt;handler使用&lt;/h2&gt;

&lt;p&gt;由于 Handler 属于 TLS（Thread Local Storage）变量，导致它的生命周期和 Activity 不一致。因此通过 Handler 来更新 UI 一般很难保证跟 View 或者 Activity 的生命周期一致，故很容易导致无法正确释放。&lt;/p&gt;

&lt;p&gt;解决办法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;弱引用+ 静态内部类。首先第一个关键是，静态内部类是不会引用外部对象的，但是我们依然需要外部的activity 处理事务，所以我们持有activity的弱引用来处理消息。弱引用的好处是当gc运行的时候，也就是退出的时候，不管内存够不够，都会回收弱引用。&lt;/li&gt;
&lt;li&gt;activity结束的时候，移除message。为啥这个也可以防止内存泄漏？回到handler内存泄漏的本质，其实就是messagequeue 里面的message持有了handler的句柄，handler持有了外部的activity，所以message如果一直在，这个activity就没有办法回收，导致内存泄漏。移除了message，源头解决了内存泄漏。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    public class MyHandler extends android.os.Handler {

        private WeakReference&amp;lt;Activity&amp;gt; mContextWeakReference;

        public MyHandler(Activity activity) {
            mContextWeakReference = new WeakReference&amp;lt;&amp;gt;(activity);
        }

        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            Activity activity = mContextWeakReference.get();
            if (activity == null || activity.isDestroyed() || activity.isFinishing()) {
                removeCallbacksAndMessages(null);
            }
            //todo logic things
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;引生一下-远离非静态内部类和匿名类&#34;&gt;引生一下：（远离非静态内部类和匿名类）&lt;/h3&gt;

&lt;p&gt;非静态内部类为什么会容易引发内存泄漏？&lt;/p&gt;

&lt;p&gt;当我们反编译app的时候，会看到非静态内部类的格式为 外部类$非静态内部类&lt;/p&gt;

&lt;p&gt;也就说说非静态内部类会持有外部类的引用，称为隐式引用。这个非静态内部类如果没有在外部类回收的时候被回收，也就是会持有外部类的引用导致外部类无法被回收。也就是内存泄漏。&lt;/p&gt;

&lt;p&gt;非静态内部类中创建了一个静态实例，导致该实例的生命周期和应用ClassLoader级别，又因为该静态实例又会隐式持有其外部类的引用，所以导致其外部类无法正常释放，出现了泄漏问题。&lt;/p&gt;

&lt;h2 id=&#34;使用系统服务引发的内存泄漏&#34;&gt;使用系统服务引发的内存泄漏&lt;/h2&gt;

&lt;p&gt;遇到的内存泄漏问题是因为在 Activity 中调用了 getPackageManger 方法获取 PMS ，该方法调用的是 ContextImpl，此时如果ContextImpl 中 PackageManager 为 null，就会创建一个 PackageManger（ContextImpl 会将自己传递进去，而 ContextImpl 的 mOuterContext 为 Activity），创建 PackageManager 实际上会创建 PackageManagerService（简称 PMS），而 PMS 的构造方法中会创建一个 UserManger（UserManger 初始化之后会持有 ContextImpl 的强引用）。
只要 PMS 的 class 未被销毁，那么就会一直引用着 UserManger ，进而导致其关联到的资源无法正常释放。&lt;/p&gt;

&lt;p&gt;解决办法&lt;/p&gt;

&lt;p&gt;将getPackageManager()改为 getApplication()#getPackageManager() 。这样引用的就是 Application Context，而非 Activity 了。&lt;/p&gt;

&lt;h2 id=&#34;webview-引发的内存泄漏&#34;&gt;WebView 引发的内存泄漏&lt;/h2&gt;

&lt;h2 id=&#34;对象的注册与反注册没有成对出现&#34;&gt;对象的注册与反注册没有成对出现&lt;/h2&gt;

&lt;p&gt;譬如注册广播接收器、注册观察者（典型的譬如数据库的监听）等。&lt;/p&gt;

&lt;h2 id=&#34;创建与关闭没有成对出现造成的泄露&#34;&gt;创建与关闭没有成对出现造成的泄露&lt;/h2&gt;

&lt;p&gt;譬如Cursor资源必须手动关闭，WebView必须手动销毁，流等对象必须手动关闭等。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>多渠道打包</title>
      <link>https://guixiaoyuan.github.io/post/2018-10-08/</link>
      <pubDate>Mon, 08 Oct 2018 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2018-10-08/</guid>
      <description>&lt;p&gt;新上的项目，需要发布12个渠道，小米，魅族，华为等等。就涉及到多渠道打包问题。小结一下。
&lt;/p&gt;

&lt;h2 id=&#34;为啥要多渠道打包&#34;&gt;为啥要多渠道打包？&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;添加渠道信息。我们要在安装包中添加不同的标识，应用在请求网络的时候携带渠道信息，方便后台做运营统计（这就是添加渠道信息的用处）。&lt;/li&gt;
&lt;li&gt;批量修改生成的apk文件名&lt;/li&gt;
&lt;li&gt;生成不同应用名称或图标&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;方法&#34;&gt;方法&lt;/h2&gt;

&lt;p&gt;umeng 渠道统计&lt;/p&gt;

&lt;p&gt;android manifest&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta-data
            android:name=&amp;quot;UMENG_CHANNEL&amp;quot;
            android:value=&amp;quot;umeng&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;build-gradle&#34;&gt;build.gradle&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;android {
    compileSdkVersion 27
    defaultConfig {
        applicationId &amp;quot;com.lemeng.reader.lemengreader&amp;quot;
        minSdkVersion 19
        targetSdkVersion 27
        multiDexEnabled true
        versionCode 1200
        versionName &amp;quot;1.2&amp;quot;
        flavorDimensions &amp;quot;versionCode&amp;quot;
        //动态配置
        manifestPlaceholders = [UMENG_CHANNEL_VALUE: &amp;quot;umeng&amp;quot;]
        ndk {
            //设置支持的SO库架构
            abiFilters &#39;armeabi&#39;, &#39;x86&#39;//, &#39;armeabi-v7a&#39;, &#39;x86_64&#39;, &#39;arm64-v8a&#39;
        }
    }


    signingConfigs {    //签名设置
        release {
            storeFile file(&amp;quot;xxxx.keystore&amp;quot;)
            storePassword &amp;quot;xxxxxx&amp;quot;
            keyAlias &amp;quot;xxxx&amp;quot;
            keyPassword &amp;quot;xxxxxx&amp;quot;
        }
        debug {
            storeFile file(&amp;quot;xxxx.keystore&amp;quot;)
            storePassword &amp;quot;xxxxxx&amp;quot;
            keyAlias &amp;quot;xxxx&amp;quot;
            keyPassword &amp;quot;xxxxxx&amp;quot;
        }
    }

    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
            buildConfigField(&amp;quot;boolean&amp;quot;, &amp;quot;LOG_DEBUG&amp;quot;, &amp;quot;false&amp;quot;)
            //签名设置
            signingConfig signingConfigs.release

            applicationVariants.all { variant -&amp;gt;
            	//定制化输出apk路径
                variant.getPackageApplication().outputDirectory = new File(project.rootDir.absolutePath+&amp;quot;/hmsq/release/&amp;quot;)
                variant.outputs.each { output -&amp;gt;
                    def outputFile = output.outputFile
                    if (outputFile != null &amp;amp;&amp;amp; outputFile.name.endsWith(&#39;release.apk&#39;)) {
                        def fileName = &amp;quot;${defaultConfig.applicationId}_${defaultConfig.versionName}_${defaultConfig.versionCode}_${variant.productFlavors[0].name}_release.apk&amp;quot;
                        output.outputFileName = new File(fileName)
                        println &amp;quot;输出文件位置： &amp;quot; + output.outputFile
                    }
                }
            }
        }

        debug {
            buildConfigField(&amp;quot;boolean&amp;quot;, &amp;quot;LOG_DEBUG&amp;quot;, &amp;quot;true&amp;quot;)
            minifyEnabled false

        }

    }

	//多个渠道设置
    productFlavors {
        // 友盟多渠道打包
        qq {}
        oppo {}
        vivo {}
        xiaomi {}
        meizu {}
        lenovo {}
        smartisan {}
        wandoujia{}
        _360 {}
        sogou {}
        huawei {}
    }

	//批量动态替换名字
    productFlavors.all { flavor -&amp;gt;
        flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后命令行执行 ./gradlew assembleRelease 即可&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>刘海屏适配问题</title>
      <link>https://guixiaoyuan.github.io/post/2018-09-212/</link>
      <pubDate>Wed, 12 Sep 2018 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2018-09-212/</guid>
      <description>&lt;p&gt;各大手机机型层出不穷，适配问题也是方法尽出。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;刘海屏适配问题&#34;&gt;刘海屏适配问题&lt;/h3&gt;

&lt;p&gt;谷歌andorid p 9.0 官方支持了刘海屏。
国内android O 8.0，各大手机厂商，自己实现了支持刘海屏幕的接口和方案。&lt;/p&gt;

&lt;p&gt;如果要适配的话，可以自己去各大手机厂商的官网去查找。主流的有华为，vivo，oppo。&lt;/p&gt;

&lt;p&gt;这个方案网上一查一大堆。适配起来也非常的简单。简单的做个总结。有兴趣可以看看&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/guixiaoyuan/AndroidUtils/blob/master/NotchScreenUtils.java&#34;&gt;NotchScreenUtils&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;今天主要 就聊聊自己在项目中的一个坑的经历。在做小说阅读的时候。阅读界面需要做沉浸式。这个时候需要适配刘海屏幕。&lt;/p&gt;

&lt;p&gt;但是出现一个情况是，我们按照刘海屏幕适配的时候，会出现一个问题，全屏展示的时候，就是默认不会出现刘海屏幕，也就是安全模式。不全屏幕的时候，刘海屏幕出现，但是无法做沉浸式的状态，也就是有刘海屏的时候，会有状态栏里面的时间，网络等信息。&lt;/p&gt;

&lt;p&gt;无法做到像qq阅读那样，阅读界面沉浸式，并且刘海可以定制化做一些操作。&lt;/p&gt;

&lt;p&gt;这个问题困扰了非常久的时间，后来才发现原因。&lt;/p&gt;

&lt;p&gt;1、你设置这些，没什么用，vivo最新版本都只是覆盖到android 8.0，而你的设置要在9.0才有效&lt;/p&gt;

&lt;p&gt;2、由于android机型的分散，考虑到屏幕兼容问题，未来刘海屏手机可能会优先默认在安全区显示，手动设置开启全屏，这取决于9.0的覆盖率&lt;/p&gt;

&lt;p&gt;vivo 默认显示安全区域。你需要手动去设置，在显示与亮度里面，找到第三方应用显示比例，你的app，全屏显示即可。&lt;/p&gt;

&lt;p&gt;qq阅读这种app，是需要联系vivo厂商，给应用设置白名单。才可更改默认显示模式。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2018元贝驾考工作经验</title>
      <link>https://guixiaoyuan.github.io/post/2018-08-23/</link>
      <pubDate>Thu, 23 Aug 2018 00:30:03 CST</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2018-08-23/</guid>
      <description>&lt;p&gt;我在 2018年 8 月份离职了，这份工作实际干了不超过4个月，主要是团队项目管理原因，每天干活干的特别憋屈，功劳是别人的，锅都是自己的。当初进入这家公司也是够蠢的，只注重短期利益，忽略长远发展，简单概括就是短视。这家公司是一个有20人不到的团队。具体的细节不阐述了。说说得到的经验教训。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;相对于稳定的体制之内的工作，到处漂泊的程序员就是无业啊尼玛！&lt;/p&gt;

&lt;p&gt;可是编程是门手艺活儿，既然选择了，那就做下去吧。&lt;/p&gt;

&lt;p&gt;经过这样的一段经历之后，以后找公司一定要有排除选项：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;看公司规模，低于 100 人的排除&lt;/li&gt;
&lt;li&gt;看公司类型，互联网公司优先，拒绝外包&lt;/li&gt;
&lt;li&gt;看公司成立时间，少于两年的排除&lt;/li&gt;
&lt;li&gt;看公司的产品是否可行，是否盈利（是否游走在法律的边缘，比如p2p，文娱）&lt;/li&gt;
&lt;li&gt;看公司的技术团队和管理层，是否名校或名企出身&lt;/li&gt;
&lt;li&gt;看公司的文化氛围，互联网文化好的优先考虑&lt;/li&gt;
&lt;li&gt;看公司在招的其他岗位，对组织架构有个大概了解&lt;/li&gt;
&lt;li&gt;同事是怎么样的&lt;/li&gt;
&lt;li&gt;老板是怎么样的&lt;/li&gt;
&lt;li&gt;工作空间的舒适程度&lt;/li&gt;
&lt;li&gt;报酬&lt;/li&gt;
&lt;li&gt;每天实际上在做的事情&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;v站上对换工作的态度，我觉得有道理。贴出来共勉。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;换工作是一件经过深思熟虑的严肃事情&lt;/li&gt;
&lt;li&gt;频繁换工作是 loser 做的事情&lt;/li&gt;
&lt;li&gt;公司应该提供给员工尽可能好的条件&lt;/li&gt;
&lt;li&gt;如果你自己从来没有从期权上赚过钱，就不要在招聘时强调期权&lt;/li&gt;
&lt;li&gt;招聘时请尽量给出薪酬范围&lt;/li&gt;
&lt;li&gt;求职时请附上自己的薪酬要求&lt;/li&gt;
&lt;li&gt;说话前经过足够的思考是好习惯&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>关于Andorid混淆</title>
      <link>https://guixiaoyuan.github.io/post/2018-07-08/</link>
      <pubDate>Sun, 08 Jul 2018 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2018-07-08/</guid>
      <description>&lt;p&gt;新公司的驾考类产品稳定运行了好几年，最近接手的时候发现居然没有进行混淆处理。这无异于在大马路上裸奔。反编译之后，分分钟拿到你的所有源码。&lt;/p&gt;

&lt;p&gt;马上将这一情况报告给leader，leader是搞ios出身的。同意了。原本以为一天就搞完了，后来的经历告诉我，还是太年轻了。&lt;/p&gt;

&lt;p&gt;接着我才理解这个项目的前辈们不搞混淆的原因，这是一条漫漫长坑。&lt;/p&gt;

&lt;p&gt;其实混淆本身不难，难的是一个项目历尽几手，尾大不掉。很多意外的坑。
&lt;/p&gt;

&lt;h1 id=&#34;关于andorid混淆&#34;&gt;关于Andorid混淆&lt;/h1&gt;

&lt;h2 id=&#34;混淆是什么&#34;&gt;混淆是什么？&lt;/h2&gt;

&lt;p&gt;Java是一种跨平台的、解释型语言，Java源代码编译成中间“字节码”存储于class文件中。由于跨平台的需要，Java字节码中包含了很多源代码信息，如变量名、方法名，并且通过这些名称来访问变量和方法，这些符号带有许多语义信息，很容易被反编译成Java源代码。为了防止这种现象，我们可以使用Java混淆器对Java字节码进行混淆。&lt;/p&gt;

&lt;p&gt;混淆就是对发布出去的程序进行重新组织和处理，使得处理后的代码与处理前代码完成相同的功能，而混淆后的代码很难被反编译，即使反编译成功也很难得出程序的真正语义。被混淆过的程序代码，仍然遵照原来的档案格式和指令集，执行结果也与混淆前一样，只是混淆器将代码中的所有变量、函数、类的名称变为简短的英文字母代号，在缺乏相应的函数名和程序注释的情况下，即使被反编译，也将难以阅读。同时混淆是不可逆的，在混淆的过程中一些不影响正常运行的信息将永久丢失，这些信息的丢失使程序变得更加难以理解。&lt;/p&gt;

&lt;p&gt;所以混淆的作用很明显&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;混淆器的作用不仅仅是保护代码，它也有精简编译后程序大小的作用。&lt;/li&gt;
&lt;li&gt;由于以上介绍的缩短变量和函数名以及丢失部分信息的原因，编译后jar文件体积大约能减少25%。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;怎么混淆&#34;&gt;怎么混淆？&lt;/h2&gt;

&lt;h3 id=&#34;开启混淆&#34;&gt;开启混淆&lt;/h3&gt;

&lt;p&gt;android studio 设置混淆非常简单。&lt;/p&gt;

&lt;p&gt;在build.gradle 文件中 设置如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  buildTypes {
        release {
            signingConfig signingConfigs.release
            // 是否进行混淆
            minifyEnabled true
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就会从你的配置文件中去读你的混淆规则，配置文件 proguard-rules.pro&lt;/p&gt;

&lt;p&gt;发布一款应用除了设minifyEnabled为ture，你也应该设置zipAlignEnabled为true，像Google Play强制要求开发者上传的应用必须是经过zipAlign的，zipAlign可以让安装包中的资源按4字节对齐，这样可以减少应用在运行时的内存消耗。&lt;/p&gt;

&lt;h3 id=&#34;制定混淆规则&#34;&gt;制定混淆规则&lt;/h3&gt;

&lt;p&gt;一般android 的混淆规则如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;jni方法不可混淆，因为这个方法需要和native方法保持一致；&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;-keepclasseswithmembernames class * { # 保持native方法不被混淆    
    native &amp;lt;methods&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;有用到 WebView 的 JS 调用也需要保证写的接口方法不混淆，原因和第一条一样&lt;/li&gt;
&lt;li&gt;使用了 Gson 之类的工具要使 JavaBean 类即实体类不被混淆（实体类都要keep住）&lt;/li&gt;
&lt;li&gt;使用了自定义控件那么要保证它们不参与混淆&lt;/li&gt;
&lt;li&gt;使用了枚举 enum 要保证枚举不被混淆&lt;/li&gt;
&lt;li&gt;对第三方库中的类不进行混淆&lt;/li&gt;
&lt;li&gt;运用了反射的类也不进行混淆&lt;/li&gt;
&lt;li&gt;在引用第三方库的时候，一般会标明库的混淆规则的，建议在使用的时候就把混淆规则添加上去，免得到最后才去找&lt;/li&gt;
&lt;li&gt;Parcelable 的子类和 Creator 静态成员变量不混淆，否则会产生 Android.os.BadParcelableException 异常&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;文章末尾会给一个通用的模版。&lt;/p&gt;

&lt;h3 id=&#34;混淆语法&#34;&gt;混淆语法&lt;/h3&gt;

&lt;p&gt;确定混淆规则&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-keep  保留类和类中的成员，防止它们被混淆或移除。

-keep xxx.xxx.*   一颗星表示不混淆该包下的类，而子包下的类还是会被混淆。
-keep xxx.xxx.**  两颗星表示都不被混淆。
-keep xxx.xxx.** { *; }  表示类内部的方法和变量都不被混淆
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;通用模版&#34;&gt;通用模版&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
#-------------------------------------------基本不用动区域--------------------------------------------
#---------------------------------基本指令区----------------------------------
#代码混淆压缩比，范围为0-7，默认为5。一般不修改
-optimizationpasses 5
# 混合时不使用大小写混合，混合后的类名为小写
-dontusemixedcaseclassnames
# 指定不去忽略非公共库的类
-dontskipnonpubliclibraryclasses
# 指定不去忽略非公共库的类成员
-dontskipnonpubliclibraryclassmembers
# 不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。
-dontpreverify
# 这句话能够使我们的项目混淆后产生映射文件
# 包含有类名-&amp;gt;混淆后类名的映射关系
-verbose
-printmapping proguardMapping.txt
# 指定混淆是采用的算法，后面的参数是一个过滤器
# 这个过滤器是谷歌推荐的算法，一般不做更改
-optimizations !code/simplification/cast,!field/*,!class/merging/*
# 保留Annotation不混淆
-keepattributes *Annotation*,InnerClasses
# 避免混淆泛型
-keepattributes Signature
# 抛出异常时保留代码行号
-keepattributes SourceFile,LineNumberTable

#---------------------------------默认保留区---------------------------------

# 保留我们使用的四大组件，自定义的Application等等这些类不被混淆
# 因为这些子类都有可能被外部调用
-keep public class * extends android.app.Activity
-keep public class * extends android.app.Application
-keep public class * extends android.app.Service
-keep public class * extends android.content.BroadcastReceiver
-keep public class * extends android.content.ContentProvider
-keep public class * extends android.app.backup.BackupAgentHelper
-keep public class * extends android.preference.Preference
-keep public class * extends android.view.View
-keep public class com.android.vending.licensing.ILicensingService

# 保留support下的所有类及其内部类
-keep class android.support.** {*;}

# 保留继承的
-keep public class * extends android.support.v4.**
-keep public class * extends android.support.v7.**
-keep public class * extends android.support.annotation.**

# 保留本地native方法不被混淆
-keepclasseswithmembernames class * {
    native &amp;lt;methods&amp;gt;;
}

# 保留在Activity中的方法参数是view的方法，
# 这样以来我们在layout中写的onClick就不会被影响
-keepclassmembers class * extends android.app.Activity{
    public void *(android.view.View);
}

# 保留枚举类不被混淆
-keepclassmembers enum * {
    public static **[] values();
    public static ** valueOf(java.lang.String);
}

# 保留我们自定义控件（继承自View）不被混淆
-keep public class * extends android.view.View{
    *** get*();
    void set*(***);
    public &amp;lt;init&amp;gt;(android.content.Context);
    public &amp;lt;init&amp;gt;(android.content.Context, android.util.AttributeSet);
    public &amp;lt;init&amp;gt;(android.content.Context, android.util.AttributeSet, int);
}
-keepclasseswithmembers class * {
    public &amp;lt;init&amp;gt;(android.content.Context, android.util.AttributeSet);
    public &amp;lt;init&amp;gt;(android.content.Context, android.util.AttributeSet, int);
}

# 保留Parcelable序列化类不被混淆
-keep class * implements android.os.Parcelable {
  public static final android.os.Parcelable$Creator *;
}
# 保留Serializable序列化的类不被混淆
-keepnames class * implements java.io.Serializable
-keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
        private static final java.io.ObjectStreamField[] serialPersistentFields;
        !static !transient &amp;lt;fields&amp;gt;;
        !private &amp;lt;fields&amp;gt;;
        !private &amp;lt;methods&amp;gt;;
        private void writeObject(java.io.ObjectOutputStream);
        private void readObject(java.io.ObjectInputStream);
        java.lang.Object writeReplace();
        java.lang.Object readResolve();
}

# 保留R下面的资源
-keep class **.R$* {
 *;
}

# 对于带有回调函数的onXXEvent、**On*Listener的，不能被混淆
-keepclassmembers class * {
    void *(**On*Event);
    void *(**On*Listener);
}

#---------------------------------webview------------------------------------
-keepclassmembers class fqcn.of.javascript.interface.for.Webview {
   public *;
}
-keepclassmembers class * extends android.webkit.WebViewClient {
    public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap);
    public boolean *(android.webkit.WebView, java.lang.String);
}
-keepclassmembers class * extends android.webkit.WebViewClient {
    public void *(android.webkit.WebView, jav.lang.String);
}

#--------------实体类---------------#

实体类优雅的混淆

* 在混淆配置文件中添加bean类包名，这样该包下所有的bean类都可以不被混淆了
* -keep public class yourBeanPackageName.**{*;} 
* 使用@keep注解（推荐）

#--------------三方包---------------#


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;常见开源框架混淆&#34;&gt;常见开源框架混淆&lt;/h2&gt;

&lt;p&gt;三方包一般去官网都能找到，实在找不到，你可以使用下面的方法。&lt;/p&gt;

&lt;p&gt;比如融云：&lt;/p&gt;

&lt;p&gt;-dontwarn io.rong.push.**&lt;/p&gt;

&lt;p&gt;-keep class io.rong.push.** {*；}&lt;/p&gt;

&lt;p&gt;如果你不知道第三方的混淆配置，就这样写，没问题的&lt;/p&gt;

&lt;h3 id=&#34;retrofit&#34;&gt;retrofit&lt;/h3&gt;

&lt;p&gt;官网给的混淆配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Platform calls Class.forName on types which do not exist on Android to determine platform.
-dontnote retrofit2.Platform
# Platform used when running on RoboVM on iOS. Will not be used at runtime.
-dontnote retrofit2.Platform$IOS$MainThreadExecutor
# Platform used when running on Java 8 VMs. Will not be used at runtime.
-dontwarn retrofit2.Platform$Java8
# Retain generic type information for use by reflection by converters and adapters.
-keepattributes Signature
# Retain declared checked exceptions for use by a Proxy instance.
-keepattributes Exceptions
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实不完全，retrofit是对Okhttp的封装，而且里面还使用了Gson转换。&lt;/p&gt;

&lt;p&gt;所以需要一个完整的封装。如下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Retrofit
-dontnote retrofit2.Platform
-dontnote retrofit2.Platform$IOS$MainThreadExecutor
-dontwarn retrofit2.Platform$Java8
-keepattributes Signature
-keepattributes Exceptions

# okhttp
-dontwarn okio.**

# Gson
-keep class com.example.testing.retrofitdemo.bean.**{*;} # 自定义数据模型的bean目录

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;volley&#34;&gt;volley&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;## -------------------------------------------
##     volley混淆
## -------------------------------------------
-keep class com.android.volley.** {*;}
-keep class com.android.volley.toolbox.** {*;}
-keep class com.android.volley.Response$* { *; }
-keep class com.android.volley.Request$* { *; }
-keep class com.android.volley.RequestQueue$* { *; }
-keep class com.android.volley.toolbox.HurlStack$* { *; }
-keep class com.android.volley.toolbox.ImageLoader$* { *; }

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;eventbus&#34;&gt;EventBus&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;## ----------------------------------
##     EventBus 相关的混淆配置
## ----------------------------------
-keepattributes *Annotation*
-keepclassmembers class ** {
    @org.greenrobot.eventbus.Subscribe &amp;lt;methods&amp;gt;;
}
-keep enum org.greenrobot.eventbus.ThreadMode { *; }
# Only required if you use AsyncExecutor
-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent {
    &amp;lt;init&amp;gt;(java.lang.Throwable);
}
-keepclassmembers class ** {
    public void onEvent*(**);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;butterknife&#34;&gt;ButterKnife&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;## ----------------------------------
##     butterknife 相关的混淆配置
## ----------------------------------
-dontwarn butterknife.internal.**
-keep class **$$ViewInjector { *; }
-keepnames class * { @butterknife.InjectView *;}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;混淆代码调试&#34;&gt;混淆代码调试&lt;/h2&gt;

&lt;p&gt;混淆后的代码出现错误怎么办呢，如何进行调试？了解一下ProGuard文件。&lt;/p&gt;

&lt;p&gt;混淆之后，会给我们输出一些文件，在gradle方式下是在&lt;project_dir&gt;/build/proguard/目录下，ant是在&lt;project_dir&gt;/bin/proguard目录，eclipse构建在&lt;project_dir&gt;/proguard目录像。
分别有以下文件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;dump.txt 描述apk文件中所有类文件间的内部结构。&lt;/li&gt;
&lt;li&gt;mapping.txt 列出了原始的类，方法，和字段名与混淆后代码之间的映射。&lt;/li&gt;
&lt;li&gt;seeds.txt 列出了未被混淆的类和成员&lt;/li&gt;
&lt;li&gt;usage.txt 列出了从apk中删除的代码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我们发布的release版本的程序出现bug时，可以通过以上文件（特别时mapping.txt）文件找到错误原始的位置，进行bug修改。同时，可能一开始的proguard配置有错误，也可以通过错误日志，根据这些文件，找到哪些文件不应该混淆，从而修改proguard的配置。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2018三月面试经历</title>
      <link>https://guixiaoyuan.github.io/post/2018-03-29/</link>
      <pubDate>Thu, 29 Mar 2018 00:30:03 CST</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2018-03-29/</guid>
      <description>&lt;p&gt;金三银四。求职的好机会。第一个需求发展，第二个看看市面上需要什么样的人才，找准自己的定位。坐标南京。面试了努比亚，苏宁，焦点科技，地平线机器人。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;地平线机器人&#34;&gt;地平线机器人&lt;/h2&gt;

&lt;p&gt;fragment与activity的交互，fragment的生命周期，什么时候绘制view。
怎么使用fragment，不带参数的fragment有什么好处？带参数的fragment会有什么弊端？&lt;/p&gt;

&lt;p&gt;android有几大布局，一般你用什么？为什么？（估计是从性能优化的角度说，但是还没搞懂后续他会问什么，因为没回答出来他满意的答案，他也没继续问）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RelativeLayout 会调用两次onMeasure()方法，
groupView自己是不会测量的，交给子view测量。
RelativeLayout会根据2次排列的结果对子View各做一次measure，一次横，一次竖。
这是为什么呢？首先RelativeLayout中子View的排列方式是基于彼此的依赖关系，
而这个依赖关系可能和Xml布局中View的顺序不同，
在确定每个子View的位置的时候，需要先给所有的子View排序一下。
又因为RelativeLayout允许ViewB在横向上依赖ViewA，ViewA在纵向上依赖B。
所以需要横向纵向分别进行一次排序测量。

LinearLayout 如果不使用weight属性，只会调用一次，使用weight属性，调用两次

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RxJava使用，Rxjava的好处。对Rxjava的理解。RxJava 操作符，比如map 和 flatMap 的区别，更高阶的东西需要去掌握;&lt;/p&gt;

&lt;p&gt;Touch事件传递。比如说我现在有个两层布局，里面有一个button，点击button的时候，说说调用的方法。&lt;/p&gt;

&lt;p&gt;封装了网络了，说说封装思路是什么？对httpClient的理解，google还支持使用它么？（这个我说不知道，估计后面本来还会问为什么不支持。)&lt;/p&gt;

&lt;p&gt;用过多线程么？多线程之间是怎么通信的。&lt;/p&gt;

&lt;p&gt;封装网路用了观察者模式，能解释观察者模式么？&lt;/p&gt;

&lt;p&gt;地平线机器人是福利待遇最好的，还没面试前，hr就开始介绍福利。技术面试官非常深入，基本上围绕你的经历然后深度挖掘内容，是技术氛围非常厉害的一家公司。&lt;/p&gt;

&lt;h2 id=&#34;努比亚&#34;&gt;努比亚&lt;/h2&gt;

&lt;p&gt;看过Glide源码么？介绍一下里面的缓存机制。&lt;/p&gt;

&lt;p&gt;用过handler么，谈谈handler机制。&lt;/p&gt;

&lt;p&gt;使用过动画么，为啥引进属性动画？&lt;/p&gt;

&lt;p&gt;了解过内存泄漏么？怎么解决的？&lt;/p&gt;

&lt;p&gt;ANR问题怎么处理？&lt;/p&gt;

&lt;p&gt;线程池用过么？&lt;/p&gt;

&lt;p&gt;中等偏上的公司，问题比较有代表性，对系统性能要求比较高。&lt;/p&gt;

&lt;h2 id=&#34;苏宁金融&#34;&gt;苏宁金融：&lt;/h2&gt;

&lt;p&gt;fragment的生命周期？view是在什么时候绘制出来的？&lt;/p&gt;

&lt;p&gt;设计模式用过么？说说你熟悉的几种？单例模式有几种。手写一个。&lt;/p&gt;

&lt;p&gt;HashMap是无序的么？说出几个无序有序的map。&lt;/p&gt;

&lt;p&gt;HashMap底层设计是什么样子的？为啥这么设计。&lt;/p&gt;

&lt;p&gt;简要说一下，hashmap put 一个数值进去，是怎么进去的。怎么查找的？又聊了聊数组。&lt;/p&gt;

&lt;p&gt;使用过kotlin么？&lt;/p&gt;

&lt;p&gt;苏宁更偏向于基础问题，面试苏宁的时候，正好碰上了苏宁扩张。面试官非常真诚，讲了很多脱离技术的问题，对于一个技术来说，还是受益匪浅的。虽然过了苏宁的技术面试，但是被人事卡下来了。工资要的过高。还是挺可惜的，没有进苏宁金融。&lt;/p&gt;

&lt;h2 id=&#34;焦点科技&#34;&gt;焦点科技&lt;/h2&gt;

&lt;p&gt;v7包里面使用过什么控件？&lt;/p&gt;

&lt;p&gt;怎么保证推送的覆盖率？&lt;/p&gt;

&lt;p&gt;进程间通信有经验么？&lt;/p&gt;

&lt;p&gt;android 安全有过经验么？&lt;/p&gt;

&lt;p&gt;service用过么？&lt;/p&gt;

&lt;p&gt;焦点科技面试我的部门。大概android7，8个人，负责7，8个app。不缺业务码农，需要对性能，安全，进程间通信方面有经验的人才。会RN，在焦点科技是加分项。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;技术上欠缺的是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;进程间通信，&lt;/li&gt;
&lt;li&gt;多线程并发，&lt;/li&gt;
&lt;li&gt;view的绘制处理，滑动事件的冲突，&lt;/li&gt;
&lt;li&gt;Android安全，&lt;/li&gt;
&lt;li&gt;java基础&lt;/li&gt;
&lt;li&gt;设计模式&lt;/li&gt;
&lt;li&gt;对开源库的代码理解&lt;/li&gt;
&lt;li&gt;RN混合开发（加分项）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要去做的是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对源码的深度理解。&lt;/li&gt;
&lt;li&gt;think in java&lt;/li&gt;
&lt;li&gt;java设计模式&lt;/li&gt;
&lt;li&gt;高并发&lt;/li&gt;
&lt;li&gt;JS那本经典&lt;/li&gt;
&lt;li&gt;Android两本经典&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Gradle从2.1升级到3.3具体的一些坑</title>
      <link>https://guixiaoyuan.github.io/post/2018-03-22/</link>
      <pubDate>Thu, 22 Mar 2018 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2018-03-22/</guid>
      <description>&lt;p&gt;最近维护原有的老项目的时候，发现gradle版本居然是2.1版本，难怪我说编译需要花费5分钟！！！尤其是现在的gradle稳定版本已经4.1+的情况下，显得更慢。&lt;/p&gt;

&lt;p&gt;本着时间就是金钱的理念，开启了我的升级填坑之旅！、
&lt;/p&gt;

&lt;p&gt;当然升级不能走的太快，太快容易扯着蛋。稳妥起见，决定先升级到3.3。（其实是公司其他项目都用3.3版本，我也很想升级到最新版本，体验快的感觉啊）&lt;/p&gt;

&lt;p&gt;第一步就是在最外层的build.gradle文件中修改版本号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;classpath &#39;com.android.tools.build:gradle:2.1.0&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;神马，版本号怎么对应？&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.android.com/studio/releases/gradle-plugin.html#revisions&#34;&gt;谷歌官方版本对应说明，需要翻墙哦&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对应下来，gradle3.3版本就是2.3.3&lt;/p&gt;

&lt;h2 id=&#34;第一个坑&#34;&gt;第一个坑&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Error:A problem was found with the configuration of task &#39;:app:packageRelease&#39;.  
&amp;gt; File &#39;E:\project-gitosc\pet\Pet-Android\Pet-Bulter\app\build\intermediates\res\resources-release-stripped.ap_&#39; specified for property &#39;resourceFile&#39; does not exist.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原因：build.gradle（app）文件中，代码混淆和移除无用的资源文件有一个为false。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解决方案：两者都必须为true&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//启用代码混淆  
minifyEnabled true  

//移除无用的资源文件  
shrinkResources true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第二个坑&#34;&gt;第二个坑&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Error:All flavors must now belong to a named flavor dimension.Learn more at https://d.android.com/r/tools/flavorDimensions-missing-error-message.html 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;原因：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Plugin 3.0.0之后有一种自动匹配消耗库的机制，便于debug variant 自动消耗一个库，然后就是必须要所有的flavor 都属于同一个维度。
为了避免flavor 不同产生误差的问题，应该在所有的库模块都使用同一个foo尺寸。具体的信息内容可以去看错误提示中的官网消息。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;解决方案：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;在主app的build.gradle里面的
 defaultConfig {
 targetSdkVersion：***
 minSdkVersion ：***
 versionCode：***
 versionName ：***
//版本名后面添加一句话，意思就是flavor dimension 它的维度就是该版本号，这样维度就是都是统一的了
flavorDimensions &amp;quot;versionCode&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第三个坑&#34;&gt;第三个坑&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Unable to load class ‘org.gradle.api.internal.component.Usage’.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;原因&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;novoda:bintray 版本老旧。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;解决方案&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;修改项目根目录下的build.gradle的版本号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buildscript {
    repositories {
        jcenter()
        google()
    }
    dependencies {
        ...
        classpath &#39;com.novoda:bintray-release:0.5.0&#39;//修改此处版本号为 0.5.0---修改之前是0.3.4
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第四个坑&#34;&gt;第四个坑&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Error:Could not resolve all files for configuration &#39;:app:xxxxxxxDebugCompileClasspath&#39;.

Failed to transform file &#39;commons-lang-2.4.jar&#39; to match attributes {artifactType=android-classes} using transform JarTransform Transform output file xxxxxxx/xxxxxxx/xxxxxxx/app/commons-lang-2.4.jar does not exist.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;原因 jar包寻找不到。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;仔细一看项目中引入jar包的方式还是很古老的&lt;/p&gt;

&lt;p&gt;compile files(&amp;lsquo;libs/mta-sdk-1.6.2.jar&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;新版本不识别。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;解决方案&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;删除原有引入方式，重新引入&lt;/p&gt;

&lt;p&gt;compile fileTree(include: [&amp;rsquo;*.jar&amp;rsquo;], dir: &amp;lsquo;libs&amp;rsquo;)&lt;/p&gt;

&lt;h2 id=&#34;第五个坑&#34;&gt;第五个坑&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Cannot set the value of read-only property ‘outputFile’ ） 
Error:(56, 0) Cannot set the value of read-only property ‘outputFile’ for ApkVariantOutputImpl_Decorated{apkData=Main{type=MAIN, fullName=debug, filters=[]}} of type com.android.build.gradle.internal.api.ApkVariantOutputImpl.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;原因，&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;自定义输出apk名字的语法出现改变。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;解决方案。如下修改。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//            applicationVariants.all { variant -&amp;gt;
//                variant.outputs.each { output -&amp;gt;
//                    def outputFile = output.outputFile
//                    if (outputFile != null &amp;amp;&amp;amp; outputFile.name.endsWith(&#39;.apk&#39;)) {
//                        def fileName = &amp;quot;你自定义.apk&amp;quot;
//                        output.outputFile = new File(outputFile.parent, fileName)
//                    }
//                }
//            }
            android.applicationVariants.all { variant -&amp;gt;
                variant.outputs.all {
                    outputFileName = &amp;quot;你自定义.apk&amp;quot;
                }
            }
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>爷爷是个老头</title>
      <link>https://guixiaoyuan.github.io/post/2018-02-09/</link>
      <pubDate>Fri, 09 Feb 2018 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2018-02-09/</guid>
      <description>&lt;p&gt;打我记事起&lt;/p&gt;

&lt;p&gt;爷爷就是个老头&lt;/p&gt;

&lt;p&gt;他那么老&lt;/p&gt;

&lt;p&gt;好像从来不曾年轻过&lt;/p&gt;

&lt;p&gt;他那么老&lt;/p&gt;

&lt;p&gt;好像生来只为了做我的爷爷&lt;/p&gt;

&lt;p&gt;可我从未认真想过他有一天会死&lt;/p&gt;

&lt;p&gt;我总以为&lt;/p&gt;

&lt;p&gt;一个人再老&lt;/p&gt;

&lt;p&gt;总可以再活一年吧&lt;/p&gt;

&lt;p&gt;然而有一天他还是死了&lt;/p&gt;

&lt;p&gt;就像土跺的院墙&lt;/p&gt;

&lt;p&gt;风雨多了&lt;/p&gt;

&lt;p&gt;总有一天会塌下来&lt;/p&gt;

&lt;p&gt;没了&lt;/p&gt;

&lt;p&gt;完了&lt;/p&gt;

&lt;p&gt;他的一生我也知道得很少&lt;/p&gt;

&lt;p&gt;他说过一些&lt;/p&gt;

&lt;p&gt;我记不大起来&lt;/p&gt;

&lt;p&gt;就像他爱我很多&lt;/p&gt;

&lt;p&gt;我只是喊他声爷爷&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于String的一点知识</title>
      <link>https://guixiaoyuan.github.io/post/2017-09-21/</link>
      <pubDate>Thu, 21 Sep 2017 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2017-09-21/</guid>
      <description>&lt;p&gt;相信大部分准备过java面试的同学都知道Java中的String是final修饰,不可变的。可是只知道是什么，不知道为什么是一件非常危险的事情。因为任何事情都没有绝对。&lt;/p&gt;

&lt;p&gt;我们先看看什么是不可变对象。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;什么是不可变对象&#34;&gt;什么是不可变对象？&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;如果一个对象，在创建完成之后，不能在改变他的状态。（包括内部成员变量，基本数据类型。引用类型的变量不能指向其他对象，引用类型指向的对象的状态）对象则认为不可改变。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于Java中的String不可变的原因，具体可以参考下面这篇文章。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/zhangjg_blog/article/details/18319521&#34;&gt;Java中的String不可变的原因&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文中源码一直分析到了1.7，但是1.8之后，String源码又改动。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final class String
    implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence {

    // The associated character storage is managed by the runtime. We only
    // keep track of the length here.
    //
    // private final char value[];
    private final int count;

    /** Cache the hash code for the string */
    private int hash; // Default to 0
    ....
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释中我们可以看到，已经把字符存储放到runtime里面去了。而且内部修改字符串，也不再是简单的new String出来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public String replace(char oldChar, char newChar) {
    String replaced = this;
    if (oldChar != newChar) {
        for (int i = 0; i &amp;lt; count; ++i) {
            if (charAt(i) == oldChar) {
                if (replaced == this) {
                    replaced = StringFactory.newStringFromString(this);
                }
                replaced.setCharAt(i, newChar);
            }
        }
    }
    return replaced;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;采用了StringFactory.newStringFromString(),这个是native方法。上述文章中提到了利用反射修改不可访问的value，从而使不可变String，变成可变String。貌似在1.8中已经被封杀了。&lt;/p&gt;

&lt;h3 id=&#34;string类不可变的好处&#34;&gt;String类不可变的好处：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;字符串池实现的前提。在运行时节约heap空间。不同字符串变量都指向同一个字符串。&lt;/li&gt;
&lt;li&gt;保障安全。直接影响：账号，密码等都以字符串的形式传递；隐形影响：HashSet，存储String内容，如果可变，破坏键值的唯一性。&lt;/li&gt;
&lt;li&gt;多线程安全。&lt;/li&gt;
&lt;li&gt;缓存Hashcode，高效。String不可变，hashcode就是一个定值。不需要重新计算，所以作为map中的键，处理速度会更快。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Android热更新</title>
      <link>https://guixiaoyuan.github.io/post/2017-08-26/</link>
      <pubDate>Sat, 26 Aug 2017 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2017-08-26/</guid>
      <description>&lt;p&gt;项目场景：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;紧急发现了一个bug，影响用户体验，阻断项目流程。这个时候，只能紧急发布一个强制更新的新版本，让用户升级。&lt;/li&gt;
&lt;li&gt;最近百团大战开始。需要增加一个活动弹窗入口，越快越好。这个时候，只能紧急发布一个强制更新的新版本，让用户升级。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;存在需求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;可不可以不让用户重新安装就可以解决上述场景？
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;什么是热更新&#34;&gt;什么是热更新：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;让应用能够在无需重新安装的情况实现更新，帮助应用快速建立动态修复能力。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的定义来看，热补丁节省Android大量应用市场发布的时间。同时用户也无需重新安装，只要上线就能无感知的更新。&lt;/p&gt;

&lt;h3 id=&#34;热更新的原理&#34;&gt;热更新的原理：&lt;/h3&gt;

&lt;p&gt;现在市面上主流的几大热更新技术：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;淘宝 Dexposed&lt;/li&gt;
&lt;li&gt;支付宝 AndFix&lt;/li&gt;
&lt;li&gt;Qzone 超级热补丁&lt;/li&gt;
&lt;li&gt;微信 Tinker&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;dexposed&#34;&gt;Dexposed&lt;/h4&gt;

&lt;p&gt;基于 Xposed 实现的无侵入的运行时 AOP (Aspect-oriented Programming)  框架，可以实现在线修复 Bug，修复粒度方法级别，这也就意味着我们没有办法进行类的增减操作。而且由于对 ART 虚拟机不支持，导致其对 Android 5.0、6.0 均不支持，使用局限性太大。&lt;/p&gt;

&lt;h3 id=&#34;andfix&#34;&gt;AndFix&lt;/h3&gt;

&lt;p&gt;native hook 方式，其核心部分在 JNI 层对方法进行替换，替换有问题的方法,修复粒度方法级别，无法在类中新增和删减字段，可以做到即时生效。也就是运行时生效。但是因为它的核心部分在JNI，所以会出现很多适配兼容的问题。因为国内的rom厂商多才多艺.&lt;/p&gt;

&lt;h3 id=&#34;超级热补丁&#34;&gt;超级热补丁&lt;/h3&gt;

&lt;p&gt;使用新的 ClassLoader 加载 patch.dex，hack 默认的 ClassLoader，替换有问题的类，修复粒度类级别，一般无法做到即时生效，需要在应用下一次启动时生效。但是在art虚拟机中，如果改变了类变量，和方法名，有可能导致内存错乱的问题，没有开源这个项目。但在github上的Nuwa采用了相同的方式，这个是开源。&lt;/p&gt;

&lt;h3 id=&#34;tinker&#34;&gt;Tinker&lt;/h3&gt;

&lt;p&gt;dex 文件全量替换，基于 DexDiff 技术，对比修复前后的 dex 文件，生成 patch.dex，再根据 patch.dex 更新有问题的 dex 文件。简单来说，在编译时通过新旧两个Dex生成差异patch.dex。在运行时，将差异patch.dex重新跟原始安装包的旧Dex还原为新的Dex。这个过程可能比较耗费时间与内存，所以我们是单独放在一个后台进程:patch中。为了补丁包尽量的小，微信自研了DexDiff算法，它深度利用Dex的格式来减少差异的大小。&lt;/p&gt;

&lt;h3 id=&#34;热更新方案的比较&#34;&gt;热更新方案的比较：&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tables&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Tinker&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Qzone&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Andfix&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Dexposed&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;类替换&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;lib替换&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;资源替换&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;全平台支持&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;即时生效&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;yes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;性能损耗&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较小&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较大&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较小&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较小&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;补丁包大小&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较小&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较大&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;一般&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;一般&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;开发透明&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;复杂度&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较低&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较低&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;复杂&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;复杂&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gradle支持&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;接口文档&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;丰富&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;一般&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;一般&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较少&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;占rom体积&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较大&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较小&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较小&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较小&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;成功率&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较好&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;最高&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;一般&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;一般&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;热更新的使用场景&#34;&gt;热更新的使用场景：&lt;/h3&gt;

&lt;p&gt;热补丁技术也可以理解为一个动态修改代码与资源的通道，它适合于修改量较少的情况。&lt;/p&gt;

&lt;p&gt;我们看一下微信的版本升级的情况：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tables&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;普通升级&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;布丁升级&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;数据大小&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;33M&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;145K&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;更新速度&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;10天&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1天（70%）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;自动升级&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;wifi&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;移动网络&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以Android用户的升级习惯，即使是相对活跃的微信也需要10天以上的时间去覆盖50%的用户。使用补丁技术，我们能做到1天覆盖70%以上。这也是基于补丁体积较小，可以直接使用移动网络下载更新。&lt;/p&gt;

&lt;h3 id=&#34;热更新使用限制&#34;&gt;热更新使用限制&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;补丁只能针对单一客户端版本，随着版本差异变大补丁体积也会增大；&lt;/li&gt;
&lt;li&gt;补丁不能支持所有的修改，例如AndroidManifest；&lt;/li&gt;
&lt;li&gt;补丁无论对代码还是资源的更新成功率都无法达到100%。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;如何在一个项目中增加热更新功能&#34;&gt;如何在一个项目中增加热更新功能？&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在工程目录 build.gradle 文件中添加插件依赖。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        // tinkersupport插件，其中latest.release指代最新版本号，也可以指定明确的版本号，例如1.0.8
        classpath &amp;quot;com.tencent.bugly:tinker-support:latest.release&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在app module 下的build.gradle 文件中添加 配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dependencies {
      compile &amp;quot;com.android.support:multidex:1.0.1&amp;quot; 
      compile &#39;com.tencent.bugly:crashreport_upgrade:latest.release&#39;
}
// 依赖插件脚本
apply from: &#39;tinker-support.gradle&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在同级目录下创建 tinker-support.gradle&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apply plugin: &#39;com.tencent.bugly.tinker-support&#39;

def bakPath = file(&amp;quot;${buildDir}/bakApk/&amp;quot;)

/**
 * 此处填写每次构建生成的基准包目录
 */
def baseApkDir = &amp;quot;app-0912-17-04-44&amp;quot;
/**
 * 对于插件各参数的详细解析请参考
 */
tinkerSupport {

    // 开启tinker-support插件，默认值true
    enable = true

    //自动生成tinkerId，无须关注此。默认为false
    //autoGenerateTinkerId = true

    tinkerEnable = true

    // 指定归档目录，默认值当前module的子目录tinker
    autoBackupApkDir = &amp;quot;${bakPath}&amp;quot;

    // 是否启用覆盖tinkerPatch配置功能，默认值false
    // 开启后tinkerPatch配置不生效，即无需添加tinkerPatch
    overrideTinkerPatchConfiguration = true

    // 编译补丁包时，必需指定基线版本的apk，默认值为空
    // 如果为空，则表示不是进行补丁包的编译
    // @{link tinkerPatch.oldApk }
    baseApk = &amp;quot;${bakPath}/${baseApkDir}/com.nongfenqi.sherlock-release-v2.3.2_32.apk&amp;quot;
    // 对应tinker插件applyMapping
    baseApkProguardMapping = &amp;quot;${bakPath}/${baseApkDir}/app-release-mapping.txt&amp;quot;

    // 对应tinker插件applyResourceMapping
    baseApkResourceMapping = &amp;quot;${bakPath}/${baseApkDir}/app-release-R.txt&amp;quot;

    // 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性
    tinkerId = &amp;quot;2.3.2-0912-patch&amp;quot;

    // 构建多渠道补丁时使用
    // buildAllFlavorsDir = &amp;quot;${bakPath}/${baseApkDir}&amp;quot;

    // 是否启用加固模式，默认为false.(tinker-spport 1.0.7起支持）
    // isProtectedApp = true

    // 是否开启反射Application模式
    enableProxyApplication = false

}

/**
 * 一般来说,我们无需对下面的参数做任何的修改
 * 对于各参数的详细介绍请参考:
 * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97
 */
tinkerPatch {
    //oldApk =&amp;quot;${bakPath}/${appName}/app-release.apk&amp;quot;
    tinkerEnable = true
    ignoreWarning = false
    useSign = true
    dex {
        dexMode = &amp;quot;jar&amp;quot;
        pattern = [&amp;quot;classes*.dex&amp;quot;]
        loader = []
    }
    lib {
        pattern = [&amp;quot;lib/*/*.so&amp;quot;]
    }

    res {
        pattern = [&amp;quot;res/*&amp;quot;, &amp;quot;r/*&amp;quot;, &amp;quot;assets/*&amp;quot;, &amp;quot;resources.arsc&amp;quot;, &amp;quot;AndroidManifest.xml&amp;quot;]
        ignoreChange = []
        largeModSize = 100
    }

    packageConfig {
    }
    sevenZip {
        zipArtifact = &amp;quot;com.tencent.mm:SevenZip:1.1.10&amp;quot;
//        path = &amp;quot;/usr/local/bin/7za&amp;quot;
    }
    buildConfig {
        keepDexApply = false
        //tinkerId = &amp;quot;1.0.1-base&amp;quot;
        //applyMapping = &amp;quot;${bakPath}/${appName}/app-release-mapping.txt&amp;quot; //  可选，设置mapping文件，建议保持旧apk的proguard混淆方式
        //applyResourceMapping = &amp;quot;${bakPath}/${appName}/app-release-R.txt&amp;quot; // 可选，设置R.txt文件，通过旧apk文件保持ResId的分配
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;权限配置以及activity配置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;uses-permission android:name=&amp;quot;android.permission.READ_PHONE_STATE&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.INTERNET&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_NETWORK_STATE&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_WIFI_STATE&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.READ_LOGS&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.WRITE_EXTERNAL_STORAGE&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.READ_EXTERNAL_STORAGE&amp;quot;/&amp;gt;


&amp;lt;activity
    android:name=&amp;quot;com.tencent.bugly.beta.ui.BetaActivity&amp;quot;
    android:theme=&amp;quot;@android:style/Theme.Translucent&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;混淆配置&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;        -dontwarn com.tencent.bugly.**
        -keep public class com.tencent.bugly.**{*;}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;</description>
    </item>
    
    <item>
      <title>存在的意义</title>
      <link>https://guixiaoyuan.github.io/post/2017-08-20/</link>
      <pubDate>Sun, 20 Aug 2017 00:30:03 CST</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2017-08-20/</guid>
      <description>&lt;p&gt;欢迎来到桂圆的第二人生。&lt;/p&gt;

&lt;p&gt;这是我的第一篇博文。万事开头难，不过凡事要具体了的话，就会很深入，深入的话就会迎刃而解。&lt;/p&gt;

&lt;h2 id=&#34;写博客的目的&#34;&gt;写博客的目的&lt;/h2&gt;

&lt;p&gt;知识管理。并且多思考，把自己思考的过程展现给大家。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为什么要知识管理？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;德鲁克说过，没有人为你负责，除了你自己，而你唯一的资本就是知识。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有兴趣的同学可以参考一般的知识管理&lt;br /&gt;
&lt;a href=&#34;http://www.jianshu.com/p/dbdac17eb9ff&#34;&gt;个人知识管理的方法&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作为一个程序员来说，IT技术更新速度迭代快，也就是意味着我们需要不断的去学习，才能不被淘汰。所以知识变成体系才格外重要。体系的管理自己的知识会让我们：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;更有效地学习新的知识。&lt;/li&gt;
&lt;li&gt;更好地掌握知识。&lt;/li&gt;
&lt;li&gt;节约时间成本。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而我自己管理知识的方法总结一下就是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;知识积累，使用文档管理工具，比如有道云笔记，Evernote等等。&lt;/li&gt;
&lt;li&gt;碎片整理，将第一步的内容初步消化。&lt;/li&gt;
&lt;li&gt;深度加工，将第二步的内容以思考的方式写成博客。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为什么推崇写博客为深度加工思考。给大家推荐两个不错的文章。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/&#34;&gt;为什么你现在就应该开始写博客&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mindhacks.cn/2009/02/09/writing-is-better-thinking/&#34;&gt;书写是为了更好的思考&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;怎么写博客&#34;&gt;怎么写博客？&lt;/h2&gt;

&lt;p&gt;明白为什么写博客的原因之后，就是去做了。理论有了之后，实践并不是一间很难的事情。&lt;/p&gt;

&lt;p&gt;我自己用的技术栈是Github pages + hugo&lt;/p&gt;

&lt;p&gt;选择hugo的原因是速度快，易上手。5000篇文章的博客，Hugo生成部署整个网站只要6秒。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://pages.github.com/&#34;&gt;Github pages官网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gohugo.io/getting-started/quick-start/&#34;&gt;hugo的初体验&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然写博客，我是默认你会markdown。如果你想让你的博客好看一点，当然也要会一点前端知识。&lt;/p&gt;

&lt;p&gt;好好的去营造属于你自己的第二人生吧。&lt;/p&gt;

&lt;h2 id=&#34;彩蛋&#34;&gt;彩蛋&lt;/h2&gt;

&lt;p&gt;当然你看到这里，不给你一点福利好像说不过去。这次的福利对听音乐的来说，可是一个爆炸性的消息。&lt;/p&gt;

&lt;p&gt;作为一个程序员来说，听着音乐敲着代码，可谓是人生一大乐事之一。但是国内版权的原因，导致了很多歌在不同的平台独家授权。个人比较喜欢用网易云音乐。可是在网易我听不到五月天，李宗盛，以及滚石唱片的所有。最近又下架了一大批歌曲。而且由于上述公司都是阿里旗下的产业，所以即使网易刚刚融到了7个亿，也不可能拿到这个版权。而韩文歌的版权也基本上被qq拿到。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;所以，这个时候，一个全平台都能听的的音乐程序呼之欲出。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://listen1.github.io/listen1/&#34;&gt;Listen 1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;目前支持windows平台，mac，linux，chrome插件，firefox插件。&lt;/p&gt;

&lt;p&gt;不涉及侵权问题，因为只是做了一个规整。听歌的链接还是各大平台。缺点就是目前没有登陆同步歌单的功能，希望有志之士可以贡献自己的力量。&lt;/p&gt;

&lt;p&gt;想做一个android app版本的，有想做的可以联系我一起贡献力量啊。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>about</title>
      <link>https://guixiaoyuan.github.io/about/</link>
      <pubDate>Mon, 10 Jul 2017 15:33:51 CST</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/about/</guid>
      <description>

&lt;h2 id=&#34;关于我&#34;&gt;关于我&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2012  CS@NUIST&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;坐标南京，90后，男。Android工程师。&lt;/p&gt;

&lt;p&gt;非典型程序猿，典型巨蟹男。虽然不是很喜欢将人标签化，但是想要快速让人了解，标签化的却是一个很好的办法。&lt;/p&gt;

&lt;p&gt;2017年的时候，决定开始写博客。缘由是想要将技术变成可读性文字。五月天有张专辑叫第二人生。这是我博客的由来。折腾一个属于自己的地盘，记录一些学习笔记和自己的想法， 要多思考，并且让人看懂你的思考。这是初衷也是愿景。&lt;/p&gt;

&lt;h2 id=&#34;喜欢&#34;&gt;喜欢：&lt;/h2&gt;

&lt;p&gt;艾弗森 五月天 李志 宫崎骏 路遥 毛姆 马尔克斯&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
