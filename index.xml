<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>桂圆的第二人生 on 桂圆的第二人生 </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>https://guixiaoyuan.github.io/</link>
    <language>en-us</language>
    <author>Xiaoyuan Gui</author>
    <copyright>Copyright (c) 2017, Xiaoyuan Gui; all rights reserved.</copyright>
    <updated>Fri, 09 Feb 2018 00:00:00 UTC</updated>
    
    <item>
      <title>爷爷是个老头</title>
      <link>https://guixiaoyuan.github.io/post/2018-02-09/</link>
      <pubDate>Fri, 09 Feb 2018 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2018-02-09/</guid>
      <description>&lt;p&gt;打我记事起&lt;/p&gt;

&lt;p&gt;爷爷就是个老头&lt;/p&gt;

&lt;p&gt;他那么老&lt;/p&gt;

&lt;p&gt;好像从来不曾年轻过&lt;/p&gt;

&lt;p&gt;他那么老&lt;/p&gt;

&lt;p&gt;好像生来只为了做我的爷爷&lt;/p&gt;

&lt;p&gt;可我从未认真想过他有一天会死&lt;/p&gt;

&lt;p&gt;我总以为&lt;/p&gt;

&lt;p&gt;一个人再老&lt;/p&gt;

&lt;p&gt;总可以再活一年吧&lt;/p&gt;

&lt;p&gt;然而有一天他还是死了&lt;/p&gt;

&lt;p&gt;就像土跺的院墙&lt;/p&gt;

&lt;p&gt;风雨多了&lt;/p&gt;

&lt;p&gt;总有一天会塌下来&lt;/p&gt;

&lt;p&gt;没了&lt;/p&gt;

&lt;p&gt;完了&lt;/p&gt;

&lt;p&gt;他的一生我也知道得很少&lt;/p&gt;

&lt;p&gt;他说过一些&lt;/p&gt;

&lt;p&gt;我记不大起来&lt;/p&gt;

&lt;p&gt;就像他爱我很多&lt;/p&gt;

&lt;p&gt;我只是喊他声爷爷&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于String的一点知识</title>
      <link>https://guixiaoyuan.github.io/post/2017-09-21/</link>
      <pubDate>Thu, 21 Sep 2017 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2017-09-21/</guid>
      <description>&lt;p&gt;相信大部分准备过java面试的同学都知道Java中的String是final修饰,不可变的。可是只知道是什么，不知道为什么是一件非常危险的事情。因为任何事情都没有绝对。&lt;/p&gt;

&lt;p&gt;我们先看看什么是不可变对象。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;什么是不可变对象&#34;&gt;什么是不可变对象？&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;如果一个对象，在创建完成之后，不能在改变他的状态。（包括内部成员变量，基本数据类型。引用类型的变量不能指向其他对象，引用类型指向的对象的状态）对象则认为不可改变。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于Java中的String不可变的原因，具体可以参考下面这篇文章。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/zhangjg_blog/article/details/18319521&#34;&gt;Java中的String不可变的原因&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文中源码一直分析到了1.7，但是1.8之后，String源码又改动。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final class String
    implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence {

    // The associated character storage is managed by the runtime. We only
    // keep track of the length here.
    //
    // private final char value[];
    private final int count;

    /** Cache the hash code for the string */
    private int hash; // Default to 0
    ....
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释中我们可以看到，已经把字符存储放到runtime里面去了。而且内部修改字符串，也不再是简单的new String出来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public String replace(char oldChar, char newChar) {
    String replaced = this;
    if (oldChar != newChar) {
        for (int i = 0; i &amp;lt; count; ++i) {
            if (charAt(i) == oldChar) {
                if (replaced == this) {
                    replaced = StringFactory.newStringFromString(this);
                }
                replaced.setCharAt(i, newChar);
            }
        }
    }
    return replaced;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;采用了StringFactory.newStringFromString(),这个是native方法。上述文章中提到了利用反射修改不可访问的value，从而使不可变String，变成可变String。貌似在1.8中已经被封杀了。&lt;/p&gt;

&lt;h3 id=&#34;string类不可变的好处&#34;&gt;String类不可变的好处：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;字符串池实现的前提。在运行时节约heap空间。不同字符串变量都指向同一个字符串。&lt;/li&gt;
&lt;li&gt;保障安全。直接影响：账号，密码等都以字符串的形式传递；隐形影响：HashSet，存储String内容，如果可变，破坏键值的唯一性。&lt;/li&gt;
&lt;li&gt;多线程安全。&lt;/li&gt;
&lt;li&gt;缓存Hashcode，高效。String不可变，hashcode就是一个定值。不需要重新计算，所以作为map中的键，处理速度会更快。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Android热更新</title>
      <link>https://guixiaoyuan.github.io/post/2017-08-26/</link>
      <pubDate>Sat, 26 Aug 2017 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2017-08-26/</guid>
      <description>&lt;p&gt;项目场景：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;紧急发现了一个bug，影响用户体验，阻断项目流程。这个时候，只能紧急发布一个强制更新的新版本，让用户升级。&lt;/li&gt;
&lt;li&gt;最近百团大战开始。需要增加一个活动弹窗入口，越快越好。这个时候，只能紧急发布一个强制更新的新版本，让用户升级。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;存在需求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;可不可以不让用户重新安装就可以解决上述场景？
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;什么是热更新&#34;&gt;什么是热更新：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;让应用能够在无需重新安装的情况实现更新，帮助应用快速建立动态修复能力。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的定义来看，热补丁节省Android大量应用市场发布的时间。同时用户也无需重新安装，只要上线就能无感知的更新。&lt;/p&gt;

&lt;h3 id=&#34;热更新的原理&#34;&gt;热更新的原理：&lt;/h3&gt;

&lt;p&gt;现在市面上主流的几大热更新技术：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;淘宝 Dexposed&lt;/li&gt;
&lt;li&gt;支付宝 AndFix&lt;/li&gt;
&lt;li&gt;Qzone 超级热补丁&lt;/li&gt;
&lt;li&gt;微信 Tinker&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;dexposed&#34;&gt;Dexposed&lt;/h4&gt;

&lt;p&gt;基于 Xposed 实现的无侵入的运行时 AOP (Aspect-oriented Programming)  框架，可以实现在线修复 Bug，修复粒度方法级别，这也就意味着我们没有办法进行类的增减操作。而且由于对 ART 虚拟机不支持，导致其对 Android 5.0、6.0 均不支持，使用局限性太大。&lt;/p&gt;

&lt;h3 id=&#34;andfix&#34;&gt;AndFix&lt;/h3&gt;

&lt;p&gt;native hook 方式，其核心部分在 JNI 层对方法进行替换，替换有问题的方法,修复粒度方法级别，无法在类中新增和删减字段，可以做到即时生效。也就是运行时生效。但是因为它的核心部分在JNI，所以会出现很多适配兼容的问题。因为国内的rom厂商多才多艺.&lt;/p&gt;

&lt;h3 id=&#34;超级热补丁&#34;&gt;超级热补丁&lt;/h3&gt;

&lt;p&gt;使用新的 ClassLoader 加载 patch.dex，hack 默认的 ClassLoader，替换有问题的类，修复粒度类级别，一般无法做到即时生效，需要在应用下一次启动时生效。但是在art虚拟机中，如果改变了类变量，和方法名，有可能导致内存错乱的问题，没有开源这个项目。但在github上的Nuwa采用了相同的方式，这个是开源。&lt;/p&gt;

&lt;h3 id=&#34;tinker&#34;&gt;Tinker&lt;/h3&gt;

&lt;p&gt;dex 文件全量替换，基于 DexDiff 技术，对比修复前后的 dex 文件，生成 patch.dex，再根据 patch.dex 更新有问题的 dex 文件。简单来说，在编译时通过新旧两个Dex生成差异patch.dex。在运行时，将差异patch.dex重新跟原始安装包的旧Dex还原为新的Dex。这个过程可能比较耗费时间与内存，所以我们是单独放在一个后台进程:patch中。为了补丁包尽量的小，微信自研了DexDiff算法，它深度利用Dex的格式来减少差异的大小。&lt;/p&gt;

&lt;h3 id=&#34;热更新方案的比较&#34;&gt;热更新方案的比较：&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tables&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Tinker&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Qzone&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Andfix&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Dexposed&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;类替换&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;lib替换&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;资源替换&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;全平台支持&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;即时生效&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;yes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;性能损耗&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较小&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较大&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较小&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较小&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;补丁包大小&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较小&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较大&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;一般&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;一般&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;开发透明&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;复杂度&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较低&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较低&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;复杂&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;复杂&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gradle支持&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;接口文档&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;丰富&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;一般&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;一般&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较少&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;占rom体积&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较大&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较小&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较小&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较小&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;成功率&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较好&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;最高&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;一般&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;一般&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;热更新的使用场景&#34;&gt;热更新的使用场景：&lt;/h3&gt;

&lt;p&gt;热补丁技术也可以理解为一个动态修改代码与资源的通道，它适合于修改量较少的情况。&lt;/p&gt;

&lt;p&gt;我们看一下微信的版本升级的情况：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tables&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;普通升级&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;布丁升级&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;数据大小&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;33M&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;145K&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;更新速度&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;10天&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1天（70%）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;自动升级&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;wifi&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;移动网络&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以Android用户的升级习惯，即使是相对活跃的微信也需要10天以上的时间去覆盖50%的用户。使用补丁技术，我们能做到1天覆盖70%以上。这也是基于补丁体积较小，可以直接使用移动网络下载更新。&lt;/p&gt;

&lt;h3 id=&#34;热更新使用限制&#34;&gt;热更新使用限制&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;补丁只能针对单一客户端版本，随着版本差异变大补丁体积也会增大；&lt;/li&gt;
&lt;li&gt;补丁不能支持所有的修改，例如AndroidManifest；&lt;/li&gt;
&lt;li&gt;补丁无论对代码还是资源的更新成功率都无法达到100%。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;如何在一个项目中增加热更新功能&#34;&gt;如何在一个项目中增加热更新功能？&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在工程目录 build.gradle 文件中添加插件依赖。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        // tinkersupport插件，其中latest.release指代最新版本号，也可以指定明确的版本号，例如1.0.8
        classpath &amp;quot;com.tencent.bugly:tinker-support:latest.release&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在app module 下的build.gradle 文件中添加 配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dependencies {
      compile &amp;quot;com.android.support:multidex:1.0.1&amp;quot; 
      compile &#39;com.tencent.bugly:crashreport_upgrade:latest.release&#39;
}
// 依赖插件脚本
apply from: &#39;tinker-support.gradle&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在同级目录下创建 tinker-support.gradle&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apply plugin: &#39;com.tencent.bugly.tinker-support&#39;

def bakPath = file(&amp;quot;${buildDir}/bakApk/&amp;quot;)

/**
 * 此处填写每次构建生成的基准包目录
 */
def baseApkDir = &amp;quot;app-0912-17-04-44&amp;quot;
/**
 * 对于插件各参数的详细解析请参考
 */
tinkerSupport {

    // 开启tinker-support插件，默认值true
    enable = true

    //自动生成tinkerId，无须关注此。默认为false
    //autoGenerateTinkerId = true

    tinkerEnable = true

    // 指定归档目录，默认值当前module的子目录tinker
    autoBackupApkDir = &amp;quot;${bakPath}&amp;quot;

    // 是否启用覆盖tinkerPatch配置功能，默认值false
    // 开启后tinkerPatch配置不生效，即无需添加tinkerPatch
    overrideTinkerPatchConfiguration = true

    // 编译补丁包时，必需指定基线版本的apk，默认值为空
    // 如果为空，则表示不是进行补丁包的编译
    // @{link tinkerPatch.oldApk }
    baseApk = &amp;quot;${bakPath}/${baseApkDir}/com.nongfenqi.sherlock-release-v2.3.2_32.apk&amp;quot;
    // 对应tinker插件applyMapping
    baseApkProguardMapping = &amp;quot;${bakPath}/${baseApkDir}/app-release-mapping.txt&amp;quot;

    // 对应tinker插件applyResourceMapping
    baseApkResourceMapping = &amp;quot;${bakPath}/${baseApkDir}/app-release-R.txt&amp;quot;

    // 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性
    tinkerId = &amp;quot;2.3.2-0912-patch&amp;quot;

    // 构建多渠道补丁时使用
    // buildAllFlavorsDir = &amp;quot;${bakPath}/${baseApkDir}&amp;quot;

    // 是否启用加固模式，默认为false.(tinker-spport 1.0.7起支持）
    // isProtectedApp = true

    // 是否开启反射Application模式
    enableProxyApplication = false

}

/**
 * 一般来说,我们无需对下面的参数做任何的修改
 * 对于各参数的详细介绍请参考:
 * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97
 */
tinkerPatch {
    //oldApk =&amp;quot;${bakPath}/${appName}/app-release.apk&amp;quot;
    tinkerEnable = true
    ignoreWarning = false
    useSign = true
    dex {
        dexMode = &amp;quot;jar&amp;quot;
        pattern = [&amp;quot;classes*.dex&amp;quot;]
        loader = []
    }
    lib {
        pattern = [&amp;quot;lib/*/*.so&amp;quot;]
    }

    res {
        pattern = [&amp;quot;res/*&amp;quot;, &amp;quot;r/*&amp;quot;, &amp;quot;assets/*&amp;quot;, &amp;quot;resources.arsc&amp;quot;, &amp;quot;AndroidManifest.xml&amp;quot;]
        ignoreChange = []
        largeModSize = 100
    }

    packageConfig {
    }
    sevenZip {
        zipArtifact = &amp;quot;com.tencent.mm:SevenZip:1.1.10&amp;quot;
//        path = &amp;quot;/usr/local/bin/7za&amp;quot;
    }
    buildConfig {
        keepDexApply = false
        //tinkerId = &amp;quot;1.0.1-base&amp;quot;
        //applyMapping = &amp;quot;${bakPath}/${appName}/app-release-mapping.txt&amp;quot; //  可选，设置mapping文件，建议保持旧apk的proguard混淆方式
        //applyResourceMapping = &amp;quot;${bakPath}/${appName}/app-release-R.txt&amp;quot; // 可选，设置R.txt文件，通过旧apk文件保持ResId的分配
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;权限配置以及activity配置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;uses-permission android:name=&amp;quot;android.permission.READ_PHONE_STATE&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.INTERNET&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_NETWORK_STATE&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_WIFI_STATE&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.READ_LOGS&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.WRITE_EXTERNAL_STORAGE&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.READ_EXTERNAL_STORAGE&amp;quot;/&amp;gt;


&amp;lt;activity
    android:name=&amp;quot;com.tencent.bugly.beta.ui.BetaActivity&amp;quot;
    android:theme=&amp;quot;@android:style/Theme.Translucent&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;混淆配置&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;        -dontwarn com.tencent.bugly.**
        -keep public class com.tencent.bugly.**{*;}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;</description>
    </item>
    
    <item>
      <title>存在的意义</title>
      <link>https://guixiaoyuan.github.io/post/2017-08-20/</link>
      <pubDate>Sun, 20 Aug 2017 00:30:03 CST</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2017-08-20/</guid>
      <description>&lt;p&gt;欢迎来到桂圆的第二人生。&lt;/p&gt;

&lt;p&gt;这是我的第一篇博文。万事开头难，不过凡事要具体了的话，就会很深入，深入的话就会迎刃而解。&lt;/p&gt;

&lt;h2 id=&#34;写博客的目的&#34;&gt;写博客的目的&lt;/h2&gt;

&lt;p&gt;知识管理。并且多思考，把自己思考的过程展现给大家。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为什么要知识管理？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;德鲁克说过，没有人为你负责，除了你自己，而你唯一的资本就是知识。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有兴趣的同学可以参考一般的知识管理&lt;br /&gt;
&lt;a href=&#34;http://www.jianshu.com/p/dbdac17eb9ff&#34;&gt;个人知识管理的方法&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作为一个程序员来说，IT技术更新速度迭代快，也就是意味着我们需要不断的去学习，才能不被淘汰。所以知识变成体系才格外重要。体系的管理自己的知识会让我们：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;更有效地学习新的知识。&lt;/li&gt;
&lt;li&gt;更好地掌握知识。&lt;/li&gt;
&lt;li&gt;节约时间成本。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而我自己管理知识的方法总结一下就是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;知识积累，使用文档管理工具，比如有道云笔记，Evernote等等。&lt;/li&gt;
&lt;li&gt;碎片整理，将第一步的内容初步消化。&lt;/li&gt;
&lt;li&gt;深度加工，将第二步的内容以思考的方式写成博客。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为什么推崇写博客为深度加工思考。给大家推荐两个不错的文章。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/&#34;&gt;为什么你现在就应该开始写博客&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mindhacks.cn/2009/02/09/writing-is-better-thinking/&#34;&gt;书写是为了更好的思考&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;怎么写博客&#34;&gt;怎么写博客？&lt;/h2&gt;

&lt;p&gt;明白为什么写博客的原因之后，就是去做了。理论有了之后，实践并不是一间很难的事情。&lt;/p&gt;

&lt;p&gt;我自己用的技术栈是Github pages + hugo&lt;/p&gt;

&lt;p&gt;选择hugo的原因是速度快，易上手。5000篇文章的博客，Hugo生成部署整个网站只要6秒。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://pages.github.com/&#34;&gt;Github pages官网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gohugo.io/getting-started/quick-start/&#34;&gt;hugo的初体验&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然写博客，我是默认你会markdown。如果你想让你的博客好看一点，当然也要会一点前端知识。&lt;/p&gt;

&lt;p&gt;好好的去营造属于你自己的第二人生吧。&lt;/p&gt;

&lt;h2 id=&#34;彩蛋&#34;&gt;彩蛋&lt;/h2&gt;

&lt;p&gt;当然你看到这里，不给你一点福利好像说不过去。这次的福利对听音乐的来说，可是一个爆炸性的消息。&lt;/p&gt;

&lt;p&gt;作为一个程序员来说，听着音乐敲着代码，可谓是人生一大乐事之一。但是国内版权的原因，导致了很多歌在不同的平台独家授权。个人比较喜欢用网易云音乐。可是在网易我听不到五月天，李宗盛，以及滚石唱片的所有。最近又下架了一大批歌曲。而且由于上述公司都是阿里旗下的产业，所以即使网易刚刚融到了7个亿，也不可能拿到这个版权。而韩文歌的版权也基本上被qq拿到。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;所以，这个时候，一个全平台都能听的的音乐程序呼之欲出。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://listen1.github.io/listen1/&#34;&gt;Listen 1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;目前支持windows平台，mac，linux，chrome插件，firefox插件。&lt;/p&gt;

&lt;p&gt;不涉及侵权问题，因为只是做了一个规整。听歌的链接还是各大平台。缺点就是目前没有登陆同步歌单的功能，希望有志之士可以贡献自己的力量。&lt;/p&gt;

&lt;p&gt;想做一个android app版本的，有想做的可以联系我一起贡献力量啊。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>about</title>
      <link>https://guixiaoyuan.github.io/about/</link>
      <pubDate>Mon, 10 Jul 2017 15:33:51 CST</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/about/</guid>
      <description>

&lt;h2 id=&#34;关于我&#34;&gt;关于我&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2012  CS@NUIST&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;坐标南京，90后，男。Android工程师。&lt;/p&gt;

&lt;p&gt;非典型程序猿，典型巨蟹男。虽然不是很喜欢将人标签化，但是想要快速让人了解，标签化的却是一个很好的办法。&lt;/p&gt;

&lt;p&gt;2017年的时候，决定开始写博客。缘由是想要将技术变成可读性文字。五月天有张专辑叫第二人生。这是我博客的由来。折腾一个属于自己的地盘，记录一些学习笔记和自己的想法， 要多思考，并且让人看懂你的思考。这是初衷也是愿景。&lt;/p&gt;

&lt;h2 id=&#34;喜欢&#34;&gt;喜欢：&lt;/h2&gt;

&lt;p&gt;艾弗森 五月天 李志 宫崎骏 路遥 毛姆 马尔克斯&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android 触摸机制</title>
      <link>https://guixiaoyuan.github.io/post/2016-03-02/</link>
      <pubDate>Wed, 02 Mar 2016 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2016-03-02/</guid>
      <description>&lt;p&gt;android开发，涉及到自定义view的时机会非常的多，完成一个非常优质的view，view必须和用户又一个非常良好的交互。view的事件处理就是一个很重要的环节。&lt;/p&gt;

&lt;p&gt;本文是对view有一定基础的总结。
&lt;/p&gt;

&lt;h1 id=&#34;android-触摸机制&#34;&gt;Android 触摸机制&lt;/h1&gt;

&lt;p&gt;在理解事件处理机制之前，我们先理解一下，view和viewGroup的异同。&lt;/p&gt;

&lt;h3 id=&#34;view&#34;&gt;view&lt;/h3&gt;

&lt;p&gt;view 在官方文档上是这么写的：This class represents the basic building block for user interface components.也就是说这个类代表用户界面组件的基本构建块。所有在ui界面上看到的东西本质上都是view.或者是从View继承过来的。&lt;/p&gt;

&lt;p&gt;比如常见的控件，textview，button，都是继承view。&lt;/p&gt;

&lt;h3 id=&#34;viewgroup&#34;&gt;viewGroup&lt;/h3&gt;

&lt;p&gt;ViewGroup在官方文档上是这么写的：The ViewGroup subclass is the base class for layouts, which are invisible containers that hold other Views (or other ViewGroups) and define their layout properties.简单来说，viewGroup就是布局。而布局我们最常见的也就是linearLayout，RealtiveLayout,FrameLayout等等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;从类结构，层级上来看,view 是包含 textview，viewGroup的。

view是根，其他的都是衍生出来的
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;从界面的包含关系上来看,viewGroup 是包含 view，viewGroup的

viewGroup是根，其他的都是附加在viewGroup上的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;理解之后，我们从操作上知道，当我们的手，去触摸屏幕的时候，界面会随着我们的操作而进行不同的交互。&lt;/p&gt;

&lt;p&gt;触摸的时候，就是一个touch事件处理的过程。&lt;/p&gt;

&lt;h3 id=&#34;touch事件&#34;&gt;touch事件&lt;/h3&gt;

&lt;p&gt;Touch事件分发中只有两个主角:ViewGroup和View。Activity的Touch事件事实上是调用它内部的ViewGroup的Touch事件，可以直接当成ViewGroup处理。&lt;/p&gt;

&lt;p&gt;简单的了解一下Android 处理触摸事件主要涉及到几个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;onInterceptTouchEvent(),（只有viewGroup有）

dipatchTouchEvent(), onTouchEvent(), onTouch()。
view和viewGroup都有
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;onInterceptTouchEvent（）从字面上看都是拦截用的。
dipatchTouchEvent（） 是分发。
onTouchEvent(), onTouch() 是处理触摸的。&lt;/p&gt;

&lt;p&gt;通过上面我们知道，view是没有拦截方法的，也就是它没有办法往下传递。所以就没有中断接受的概念。&lt;/p&gt;

&lt;p&gt;其实在view中，dispatchTouchEvent（）没什么意思。因为，它分发这个事件，其实就是给自己处理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;所以，一般情况下，我们不该在普通View内重写
dispatchTouchEvent方法，因为它并不执行分发逻辑。
当Touch事件到达View时，我们该做的就是是否在
onTouchEvent事件中处理它。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;触摸事件具体调用顺序&#34;&gt;触摸事件具体调用顺序&lt;/h3&gt;

&lt;p&gt;默认情况下，我们的动作都是从最外层传递到最里层的，一般简单的来说，也就是从ViewGroup到view。而实际处理，则是从最里层开始，一层层到外层。也就是view到ViewGroup。&lt;/p&gt;

&lt;p&gt;首先会调用最外层的dispatchTouchEvent()，其实这个方法就是分发事件，返回false，表示此层不接受这个动作，继续发送给下层。如果是true，则不传递动作给下面了。如果是viewGroup的话，接下来会调用onInterceptTouchEvent(),此方法用于拦截动作，返回true，拦截成功，false，不拦截。&lt;/p&gt;

&lt;p&gt;动作传递到下一层之后，会继续重复上面的动作。直到传递到最里层，也就是上图的叶子节点。这个时候，会调用onTouchEvent事件。如果返回false，表示继续往上传递，会调用上层的onTouchEvent()的事件，重复一直到执行到最上层。也就是上图的根节点。&lt;/p&gt;

&lt;p&gt;在这里有一件事情要注意，也就是，只有当viewGroup里面的所有子控件返回的都是false，才会执行viewGroup的onTouchEvent（）。&lt;/p&gt;

&lt;p&gt;在目前的情况看来， 似乎只要我们把所有的onTouchEvent都返回false，就能保证所有的子控件都响应本次Touch事件了。但必须要说明的是，这里的Touch 事件，只限于Acition_Down事件，即触摸按下事件,而Aciton_UP和Action_MOVE却不会执行。事实上，一次完整的Touch事 件，应该是由一个Down、一个Up和若干个Move组成的。Down方式通过dispatchTouchEvent分发，分发的目的是为了找到真正需要 处理完整Touch请求的View。当某个View或者ViewGroup的onTouchEvent事件返回true时，便表示它是真正要处理这次请求 的View，之后的Aciton_UP和Action_MOVE将由它处理。当所有子View的onTouchEvent都返回false时，这次的 Touch请求就由根ViewGroup，即Activity自己处理了。&lt;/p&gt;

&lt;h3 id=&#34;总结一下&#34;&gt;总结一下&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Touch 事件分发中只有两个主角:ViewGroup和View。ViewGroup包含onInterceptTouchEvent、 dispatchTouchEvent、onTouchEvent三个相关事件。View包含dispatchTouchEvent、 onTouchEvent两个相关事件。其中ViewGroup又继承于View。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ViewGroup和View组成了一个树状结构，根节点为Activity内部包含的一个ViwGroup。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;触摸事件由Action_Down、Action_Move、Aciton_UP组成，其中一次完整的触摸事件中，Down和Up都只有一个，Move有若干个，可以为0个。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当Acitivty接收到Touch事件时，将遍历子View进行Down事件的分发。ViewGroup的遍历可以看成是递归的。分发的目的是为了找到真正要处理本次完整触摸事件的View，这个View会在onTouchuEvent结果返回true。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当某个子 View返回true时，会中止Down事件的分发，同时在ViewGroup中记录该子View。接下去的Move和Up事件将由该子View直接进行 处理。由于子View是保存在ViewGroup中的，多层ViewGroup的节点结构时，上级ViewGroup保存的会是真实处理事件的View所 在的ViewGroup对象:如ViewGroup0-ViewGroup1-TextView的结构中，TextView返回了true，它将被保存在 ViewGroup1中，而ViewGroup1也会返回true，被保存在ViewGroup0中。当Move和UP事件来时，会先从 ViewGroup0传递至ViewGroup1，再由ViewGroup1传递至TextView。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当 ViewGroup中所有子View都不捕获Down事件时，将触发ViewGroup自身的onTouch事件。触发的方式是调用 super.dispatchTouchEvent函数，即父类View的dispatchTouchEvent方法。在所有子View都不处理的情况 下，触发Acitivity的onTouchEvent方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;onInterceptTouchEvent有两个作用：1.拦截Down事件的分发。2.中止Up和Move事件向目标View传递，使得目标View所在的ViewGroup捕获Up和Move事件。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>浅谈Android ANR</title>
      <link>https://guixiaoyuan.github.io/post/2016-02-23/</link>
      <pubDate>Tue, 23 Feb 2016 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2016-02-23/</guid>
      <description>&lt;p&gt;使用android手机的时候，有时候会出现卡屏，无法动弹的情况。本文就简单的说明一下程序无响应的问题。
&lt;/p&gt;

&lt;h1 id=&#34;浅谈android-anr&#34;&gt;浅谈Android ANR&lt;/h1&gt;

&lt;p&gt;ANR is Application Not Responding.&lt;/p&gt;

&lt;h2 id=&#34;现象&#34;&gt;现象&lt;/h2&gt;

&lt;p&gt;用户感知为程序长时间无法响应，Android系统自身会弹出一个对话框，告知需要等待，还是杀死程序。&lt;/p&gt;

&lt;h2 id=&#34;原因&#34;&gt;原因&lt;/h2&gt;

&lt;p&gt;应用程序主线程在超时时间内对输入事件没有处理完毕，或者对特定操作没有执行完毕，就会出现ANR。&lt;/p&gt;

&lt;h2 id=&#34;anr的类型&#34;&gt;ANR的类型&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;KeyDispatchTimeout(5 seconds)
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主要类型，系统会显示对话框提示。按键或触摸事件在特定时间内无响应。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  可能出现的两种情况
  1，用户输入事件处理超时；2，窗口获取焦点超时
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;BroadcastTimeout(10 seconds)  &lt;/p&gt;

&lt;p&gt;系统仅仅输出log而已，BroadcastReceiver在特定时间内无法处理完成&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ServiceTimeout(20 seconds)  &lt;/p&gt;

&lt;p&gt;系统仅仅输出log而已，Service在特定时间内无法处理完成&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ContentProvider相关操作执行超时，（I/O耗时操作）,在UI线程中进行网络操作，也容易引发ANR。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;解决套路&#34;&gt;解决套路&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;第一种情况&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;Log提示语：Reason:Input dispatching timed out(Waiting because the focused window has not finished processing the input events that were previously delivered to it);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;产生这种ANR的前提是要有输入事件，如果用户没有触发任何输入事件，即使是主线程阻塞，也不会产生ANR，因为InputDispatcer没有分发事件给应用程序，所以不会检测处理超时，以及报告ANR。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第二种情况：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;Log提示语：Reason:Input dispatching timed out(Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如何避免KeyDispatchTimeout&lt;/p&gt;

&lt;p&gt;1：UI线程尽量只做跟UI相关的工作&lt;/p&gt;

&lt;p&gt;2：耗时的工作（比如数据库操作，I/O，连接网络或者别的有可能阻碍UI线程的操作）把它放入单独的线程处理&lt;/p&gt;

&lt;p&gt;3：尽量用Handler来处理UIthread和别的thread之间的交互&lt;/p&gt;

&lt;h2 id=&#34;android的一些耗时操作&#34;&gt;android的一些耗时操作&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;数据库操作。数据库操作尽量采用异步方法做处理。&lt;/li&gt;
&lt;li&gt;初始化的数据和控件太多。&lt;/li&gt;
&lt;li&gt;频繁的创建线程或者其他大对象。&lt;/li&gt;
&lt;li&gt;加载过大数据和图片&lt;/li&gt;
&lt;li&gt;对大树据排序和循环操作&lt;/li&gt;
&lt;li&gt;过多的广播和滥用广播&lt;/li&gt;
&lt;li&gt;大树据的传递和共享&lt;/li&gt;
&lt;li&gt;访问网络&lt;/li&gt;
&lt;li&gt;避免在循环中创建对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;最后一点小体会&#34;&gt;最后一点小体会&lt;/h2&gt;

&lt;p&gt;Thread.sleep();表示主动休眠，无论你设置为多长时间，只要你在睡眠的时候，不进行其他的操作，都不会造成anr。&lt;/p&gt;

&lt;p&gt;如果你在代码中，直接引用Thread, 在ui线程中，就是ui thread。在子线程中，就是子线程 thread。&lt;/p&gt;

&lt;p&gt;直接new Thread().start().这个就是创建一个子线程，ui线程和子线程会一起执行。如果对同一个资源进行操作，所以才会产生死锁现象&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 如何根据XML文件读取drawable资源</title>
      <link>https://guixiaoyuan.github.io/post/2016-01-06/</link>
      <pubDate>Wed, 06 Jan 2016 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2016-01-06/</guid>
      <description>&lt;p&gt;问题提出的背景：自己在做launcher的新功能，摇一摇切换壁纸的时候。需要动态获取壁纸的id，然后填充到布局上。这样在后期维护的时候，就不需要过多的改动代码，直接增减图片，以及在配置文件（wallpapers.xml）中修改就好了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一种做法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在XML文件中声明资源ID数组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;array name = &amp;quot;drawer_icon_normal&amp;quot;&amp;gt;
        &amp;lt;item&amp;gt;@drawable/ic_drawer_home_normal&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;@drawable/ic_drawer_follow_normal&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;@drawable/ic_drawer_collect_normal&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;@drawable/ic_drawer_register_normal&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;@drawable/ic_drawer_explore_normal&amp;lt;/item&amp;gt;
    &amp;lt;/array&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后要获取ID需要通过TypedArray来获取。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TypedArray array = context.getResources().obtainTypedArray(R.array.drawer_icon_normal);
    for (int i = 0; i &amp;lt; array.length(); i++) {
        drawables_normal[i] = array.getResourceId(i$, R.drawable.default_profile);//后面的drawable文件是找不到资源加载的的文件
    }
    array.recycle();
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;第二种做法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;xml文件中声明有所不同。没有了@drawable，所以在获取图片名字的时候，直接是名字，而不是路径。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;array name = &amp;quot;drawer_icon_normal&amp;quot;&amp;gt;
        &amp;lt;item&amp;gt;ic_drawer_home_normal&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;ic_drawer_follow_normal&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;ic_drawer_collect_normal&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;ic_drawer_register_normal&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;ic_drawer_explore_normal&amp;lt;/item&amp;gt;
    &amp;lt;/array&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后获取Id的方法如下：&lt;/p&gt;

&lt;p&gt;获取图片的文件名的方法：&lt;/p&gt;

&lt;p&gt;String[] extras = getContext.getResources().getStringArray(R.array.drawer_icon_normal);&lt;/p&gt;

&lt;p&gt;packageName的获取方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;getContext.getResources().getResourcesPackageName(R.array.drawer_icon_normal);
int resId =  getContext().getResources().getIdentifier(&amp;quot;图片的文件名&amp;quot;，&amp;quot;文件的类型，如drawable&amp;quot;，&amp;quot;文件的packageName  一般为getContext.getPackageName()&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>ViewHolder 小结</title>
      <link>https://guixiaoyuan.github.io/post/2015-12-23/</link>
      <pubDate>Wed, 23 Dec 2015 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2015-12-23/</guid>
      <description>&lt;p&gt;adapter用的很多，android 5.0之后，采用recycleview来取代之前的listview。其中最大的一点就是让大家习惯于用viewholder.自己小结一下viewHolder的好处。&lt;/p&gt;

&lt;p&gt;根据android对view的绘制原理，我们可以看到每一次对画布中view的寻找，是自上而下的，所以每一次findviewbyId的消耗非常大。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;所以根据为了减少不必要的资源浪费，我们直接将找到的id资源，暂存起来。也就是放进ViewHolder中。&lt;/p&gt;

&lt;p&gt;viewHolder不是一个缓存类，只是一个静态类。&lt;/p&gt;

&lt;h3 id=&#34;2-convertview中的tag&#34;&gt;2.convertView中的TAG：&lt;/h3&gt;

&lt;p&gt;(1).Tag不像ID是用标示view的。Tag从本质上来讲是就是相关联的view的额外的信息。它们经常用来存储一些view的数据，这样做非常方便而不用存入另外的单独结构。&lt;/p&gt;

&lt;p&gt;(2). 首先我们要知道setTag方法是干什么的：他是给View对象的一个标签。&lt;/p&gt;

&lt;p&gt;*标签可以是任何内容，我们这里把他设置成了一个对象*，&lt;/p&gt;

&lt;p&gt;因为我们是把vlist2.xml的元素抽象出来成为一个类ViewHolder，用了setTag，这个标签就是ViewHolder实例化后对象的一个属性。我们之后对于ViewHolder实例化的对象holder的操作，都会因为java的引用机制而一直存活并改变convertView的内容，而不是每次都是去new一个。我们就这样达到的重用。&lt;/p&gt;

&lt;p&gt;Tag的作用就是设置标签，标签可以是任意玩意。
以及convertView是如何在程序中使代码运行变的效率的：利用缓存convertView尽可能少实例化同样结构体的对象；&lt;/p&gt;

&lt;p&gt;自己在写demo的时候，本来是想看滑动listview，item的加载情况。没想到，意外的发现了getView的重复调用的情况。&lt;/p&gt;

&lt;p&gt;在布局中将listview里高度设置成wrap_parent。计算父控件的高度所以造成了一种反复调用情况，从而次数不确定。&lt;/p&gt;

&lt;p&gt;当我们固定listview的高度时（fill_parent或直接固定高度），那么listview很容易就能计算出容器内可以显示多少行。但如果我们使用了“wrap_content”，只有在屏幕内控件完全加载后才知道到底能显示多少行数据时，ListView自身便会做一些尝试性计算。在源码中可以发现一些叫做onMeasure的方法，目测是做此用处(源码略显复杂，没读透)。
当listview计算出屏幕一共需要多少行后，如果listview自身高度不变，那么它的容纳的行数就不会变，使用getChildCount()可以得到它的最大行数。&lt;/p&gt;

&lt;p&gt;更深层次的解释为:
View在Draw的时候分成两个阶段：measure和layout，在measure阶段时主要就是为了计算两个参数：height和width。而且要注意的是，这是个递归的过程，从顶向下，DecorView开始依次调用自己子元素的measure。计算完成这两个参数后就开始layout，最后再是draw的调用。
对于ListView，当然每一个Item都会被调用measure方法，而在这个过程中getView和getCount会被调用，而且看用户的需求，可能会有很多次调用。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
