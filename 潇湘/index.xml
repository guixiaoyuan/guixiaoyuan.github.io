<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>潇湘s on 桂圆的第二人生 </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>https://guixiaoyuan.github.io/%E6%BD%87%E6%B9%98/</link>
    <language>en-us</language>
    <author>Xiaoyuan Gui</author>
    <copyright>Copyright (c) 2017, Xiaoyuan Gui; all rights reserved.</copyright>
    <updated>Tue, 23 Oct 2018 00:00:00 UTC</updated>
    
    <item>
      <title>关于Andorid内存泄漏</title>
      <link>https://guixiaoyuan.github.io/post/2018-10-23/</link>
      <pubDate>Tue, 23 Oct 2018 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2018-10-23/</guid>
      <description>&lt;p&gt;OOM问题会经常困扰我们，尤其是维护一个用户数量基数大的app的时候，我们的bug统计数据前几位，基本上会被OOM问题给占据。通过结果反向分析问题，和在写代码的时候注意内存泄漏从而避免OOM，本质上都需要对内存泄漏的产生，以及几种常见的方式需要有着清晰的认识。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;内存泄漏的根本原因&#34;&gt;内存泄漏的根本原因：&lt;/h1&gt;

&lt;p&gt;长生命周期的对象 持有 短生命周期 的强/弱引用，导致本应该被回收的短生命周期的对象无法被正常回收。&lt;/p&gt;

&lt;h1 id=&#34;内存泄漏的情况&#34;&gt;内存泄漏的情况&lt;/h1&gt;

&lt;h2 id=&#34;单例模式&#34;&gt;单例模式&lt;/h2&gt;

&lt;p&gt;由于单例模式的静态特性，使得它的生命周期和我们的应用一样长，一不小心让单例无限制的持有 Activity 的强引用就会导致内存泄漏。&lt;/p&gt;

&lt;p&gt;解决办法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class BaseApplication extends Application{
    private static ApplicationContext sContext;
    @Override
    public void onCreate(){
        super.onCreate();
        //全局的context，不再使用activity的引用
        sContext = getApplicationContext();
    }
    public static Context getApplicationContext(){
        return sContext;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;handler使用&#34;&gt;handler使用&lt;/h2&gt;

&lt;p&gt;由于 Handler 属于 TLS（Thread Local Storage）变量，导致它的生命周期和 Activity 不一致。因此通过 Handler 来更新 UI 一般很难保证跟 View 或者 Activity 的生命周期一致，故很容易导致无法正确释放。&lt;/p&gt;

&lt;p&gt;解决办法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;弱引用+ 静态内部类。首先第一个关键是，静态内部类是不会引用外部对象的，但是我们依然需要外部的activity 处理事务，所以我们持有activity的弱引用来处理消息。弱引用的好处是当gc运行的时候，也就是退出的时候，不管内存够不够，都会回收弱引用。&lt;/li&gt;
&lt;li&gt;activity结束的时候，移除message。为啥这个也可以防止内存泄漏？回到handler内存泄漏的本质，其实就是messagequeue 里面的message持有了handler的句柄，handler持有了外部的activity，所以message如果一直在，这个activity就没有办法回收，导致内存泄漏。移除了message，源头解决了内存泄漏。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    public class MyHandler extends android.os.Handler {

        private WeakReference&amp;lt;Activity&amp;gt; mContextWeakReference;

        public MyHandler(Activity activity) {
            mContextWeakReference = new WeakReference&amp;lt;&amp;gt;(activity);
        }

        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            Activity activity = mContextWeakReference.get();
            if (activity == null || activity.isDestroyed() || activity.isFinishing()) {
                removeCallbacksAndMessages(null);
            }
            //todo logic things
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;引生一下-远离非静态内部类和匿名类&#34;&gt;引生一下：（远离非静态内部类和匿名类）&lt;/h3&gt;

&lt;p&gt;非静态内部类为什么会容易引发内存泄漏？&lt;/p&gt;

&lt;p&gt;当我们反编译app的时候，会看到非静态内部类的格式为 外部类$非静态内部类&lt;/p&gt;

&lt;p&gt;也就说说非静态内部类会持有外部类的引用，称为隐式引用。这个非静态内部类如果没有在外部类回收的时候被回收，也就是会持有外部类的引用导致外部类无法被回收。也就是内存泄漏。&lt;/p&gt;

&lt;p&gt;非静态内部类中创建了一个静态实例，导致该实例的生命周期和应用ClassLoader级别，又因为该静态实例又会隐式持有其外部类的引用，所以导致其外部类无法正常释放，出现了泄漏问题。&lt;/p&gt;

&lt;h2 id=&#34;使用系统服务引发的内存泄漏&#34;&gt;使用系统服务引发的内存泄漏&lt;/h2&gt;

&lt;p&gt;遇到的内存泄漏问题是因为在 Activity 中调用了 getPackageManger 方法获取 PMS ，该方法调用的是 ContextImpl，此时如果ContextImpl 中 PackageManager 为 null，就会创建一个 PackageManger（ContextImpl 会将自己传递进去，而 ContextImpl 的 mOuterContext 为 Activity），创建 PackageManager 实际上会创建 PackageManagerService（简称 PMS），而 PMS 的构造方法中会创建一个 UserManger（UserManger 初始化之后会持有 ContextImpl 的强引用）。
只要 PMS 的 class 未被销毁，那么就会一直引用着 UserManger ，进而导致其关联到的资源无法正常释放。&lt;/p&gt;

&lt;p&gt;解决办法&lt;/p&gt;

&lt;p&gt;将getPackageManager()改为 getApplication()#getPackageManager() 。这样引用的就是 Application Context，而非 Activity 了。&lt;/p&gt;

&lt;h2 id=&#34;webview-引发的内存泄漏&#34;&gt;WebView 引发的内存泄漏&lt;/h2&gt;

&lt;h2 id=&#34;对象的注册与反注册没有成对出现&#34;&gt;对象的注册与反注册没有成对出现&lt;/h2&gt;

&lt;p&gt;譬如注册广播接收器、注册观察者（典型的譬如数据库的监听）等。&lt;/p&gt;

&lt;h2 id=&#34;创建与关闭没有成对出现造成的泄露&#34;&gt;创建与关闭没有成对出现造成的泄露&lt;/h2&gt;

&lt;p&gt;譬如Cursor资源必须手动关闭，WebView必须手动销毁，流等对象必须手动关闭等。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>多渠道打包</title>
      <link>https://guixiaoyuan.github.io/post/2018-10-08/</link>
      <pubDate>Mon, 08 Oct 2018 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2018-10-08/</guid>
      <description>&lt;p&gt;新上的项目，需要发布12个渠道，小米，魅族，华为等等。就涉及到多渠道打包问题。小结一下。
&lt;/p&gt;

&lt;h2 id=&#34;为啥要多渠道打包&#34;&gt;为啥要多渠道打包？&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;添加渠道信息。我们要在安装包中添加不同的标识，应用在请求网络的时候携带渠道信息，方便后台做运营统计（这就是添加渠道信息的用处）。&lt;/li&gt;
&lt;li&gt;批量修改生成的apk文件名&lt;/li&gt;
&lt;li&gt;生成不同应用名称或图标&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;方法&#34;&gt;方法&lt;/h2&gt;

&lt;p&gt;umeng 渠道统计&lt;/p&gt;

&lt;p&gt;android manifest&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta-data
            android:name=&amp;quot;UMENG_CHANNEL&amp;quot;
            android:value=&amp;quot;umeng&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;build-gradle&#34;&gt;build.gradle&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;android {
    compileSdkVersion 27
    defaultConfig {
        applicationId &amp;quot;com.lemeng.reader.lemengreader&amp;quot;
        minSdkVersion 19
        targetSdkVersion 27
        multiDexEnabled true
        versionCode 1200
        versionName &amp;quot;1.2&amp;quot;
        flavorDimensions &amp;quot;versionCode&amp;quot;
        //动态配置
        manifestPlaceholders = [UMENG_CHANNEL_VALUE: &amp;quot;umeng&amp;quot;]
        ndk {
            //设置支持的SO库架构
            abiFilters &#39;armeabi&#39;, &#39;x86&#39;//, &#39;armeabi-v7a&#39;, &#39;x86_64&#39;, &#39;arm64-v8a&#39;
        }
    }


    signingConfigs {    //签名设置
        release {
            storeFile file(&amp;quot;xxxx.keystore&amp;quot;)
            storePassword &amp;quot;xxxxxx&amp;quot;
            keyAlias &amp;quot;xxxx&amp;quot;
            keyPassword &amp;quot;xxxxxx&amp;quot;
        }
        debug {
            storeFile file(&amp;quot;xxxx.keystore&amp;quot;)
            storePassword &amp;quot;xxxxxx&amp;quot;
            keyAlias &amp;quot;xxxx&amp;quot;
            keyPassword &amp;quot;xxxxxx&amp;quot;
        }
    }

    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
            buildConfigField(&amp;quot;boolean&amp;quot;, &amp;quot;LOG_DEBUG&amp;quot;, &amp;quot;false&amp;quot;)
            //签名设置
            signingConfig signingConfigs.release

            applicationVariants.all { variant -&amp;gt;
            	//定制化输出apk路径
                variant.getPackageApplication().outputDirectory = new File(project.rootDir.absolutePath+&amp;quot;/hmsq/release/&amp;quot;)
                variant.outputs.each { output -&amp;gt;
                    def outputFile = output.outputFile
                    if (outputFile != null &amp;amp;&amp;amp; outputFile.name.endsWith(&#39;release.apk&#39;)) {
                        def fileName = &amp;quot;${defaultConfig.applicationId}_${defaultConfig.versionName}_${defaultConfig.versionCode}_${variant.productFlavors[0].name}_release.apk&amp;quot;
                        output.outputFileName = new File(fileName)
                        println &amp;quot;输出文件位置： &amp;quot; + output.outputFile
                    }
                }
            }
        }

        debug {
            buildConfigField(&amp;quot;boolean&amp;quot;, &amp;quot;LOG_DEBUG&amp;quot;, &amp;quot;true&amp;quot;)
            minifyEnabled false

        }

    }

	//多个渠道设置
    productFlavors {
        // 友盟多渠道打包
        qq {}
        oppo {}
        vivo {}
        xiaomi {}
        meizu {}
        lenovo {}
        smartisan {}
        wandoujia{}
        _360 {}
        sogou {}
        huawei {}
    }

	//批量动态替换名字
    productFlavors.all { flavor -&amp;gt;
        flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后命令行执行 ./gradlew assembleRelease 即可&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于Andorid混淆</title>
      <link>https://guixiaoyuan.github.io/post/2018-07-08/</link>
      <pubDate>Sun, 08 Jul 2018 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2018-07-08/</guid>
      <description>&lt;p&gt;新公司的驾考类产品稳定运行了好几年，最近接手的时候发现居然没有进行混淆处理。这无异于在大马路上裸奔。反编译之后，分分钟拿到你的所有源码。&lt;/p&gt;

&lt;p&gt;马上将这一情况报告给leader，leader是搞ios出身的。同意了。原本以为一天就搞完了，后来的经历告诉我，还是太年轻了。&lt;/p&gt;

&lt;p&gt;接着我才理解这个项目的前辈们不搞混淆的原因，这是一条漫漫长坑。&lt;/p&gt;

&lt;p&gt;其实混淆本身不难，难的是一个项目历尽几手，尾大不掉。很多意外的坑。
&lt;/p&gt;

&lt;h1 id=&#34;关于andorid混淆&#34;&gt;关于Andorid混淆&lt;/h1&gt;

&lt;h2 id=&#34;混淆是什么&#34;&gt;混淆是什么？&lt;/h2&gt;

&lt;p&gt;Java是一种跨平台的、解释型语言，Java源代码编译成中间“字节码”存储于class文件中。由于跨平台的需要，Java字节码中包含了很多源代码信息，如变量名、方法名，并且通过这些名称来访问变量和方法，这些符号带有许多语义信息，很容易被反编译成Java源代码。为了防止这种现象，我们可以使用Java混淆器对Java字节码进行混淆。&lt;/p&gt;

&lt;p&gt;混淆就是对发布出去的程序进行重新组织和处理，使得处理后的代码与处理前代码完成相同的功能，而混淆后的代码很难被反编译，即使反编译成功也很难得出程序的真正语义。被混淆过的程序代码，仍然遵照原来的档案格式和指令集，执行结果也与混淆前一样，只是混淆器将代码中的所有变量、函数、类的名称变为简短的英文字母代号，在缺乏相应的函数名和程序注释的情况下，即使被反编译，也将难以阅读。同时混淆是不可逆的，在混淆的过程中一些不影响正常运行的信息将永久丢失，这些信息的丢失使程序变得更加难以理解。&lt;/p&gt;

&lt;p&gt;所以混淆的作用很明显&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;混淆器的作用不仅仅是保护代码，它也有精简编译后程序大小的作用。&lt;/li&gt;
&lt;li&gt;由于以上介绍的缩短变量和函数名以及丢失部分信息的原因，编译后jar文件体积大约能减少25%。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;怎么混淆&#34;&gt;怎么混淆？&lt;/h2&gt;

&lt;h3 id=&#34;开启混淆&#34;&gt;开启混淆&lt;/h3&gt;

&lt;p&gt;android studio 设置混淆非常简单。&lt;/p&gt;

&lt;p&gt;在build.gradle 文件中 设置如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  buildTypes {
        release {
            signingConfig signingConfigs.release
            // 是否进行混淆
            minifyEnabled true
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就会从你的配置文件中去读你的混淆规则，配置文件 proguard-rules.pro&lt;/p&gt;

&lt;p&gt;发布一款应用除了设minifyEnabled为ture，你也应该设置zipAlignEnabled为true，像Google Play强制要求开发者上传的应用必须是经过zipAlign的，zipAlign可以让安装包中的资源按4字节对齐，这样可以减少应用在运行时的内存消耗。&lt;/p&gt;

&lt;h3 id=&#34;制定混淆规则&#34;&gt;制定混淆规则&lt;/h3&gt;

&lt;p&gt;一般android 的混淆规则如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;jni方法不可混淆，因为这个方法需要和native方法保持一致；&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;-keepclasseswithmembernames class * { # 保持native方法不被混淆    
    native &amp;lt;methods&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;有用到 WebView 的 JS 调用也需要保证写的接口方法不混淆，原因和第一条一样&lt;/li&gt;
&lt;li&gt;使用了 Gson 之类的工具要使 JavaBean 类即实体类不被混淆（实体类都要keep住）&lt;/li&gt;
&lt;li&gt;使用了自定义控件那么要保证它们不参与混淆&lt;/li&gt;
&lt;li&gt;使用了枚举 enum 要保证枚举不被混淆&lt;/li&gt;
&lt;li&gt;对第三方库中的类不进行混淆&lt;/li&gt;
&lt;li&gt;运用了反射的类也不进行混淆&lt;/li&gt;
&lt;li&gt;在引用第三方库的时候，一般会标明库的混淆规则的，建议在使用的时候就把混淆规则添加上去，免得到最后才去找&lt;/li&gt;
&lt;li&gt;Parcelable 的子类和 Creator 静态成员变量不混淆，否则会产生 Android.os.BadParcelableException 异常&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;文章末尾会给一个通用的模版。&lt;/p&gt;

&lt;h3 id=&#34;混淆语法&#34;&gt;混淆语法&lt;/h3&gt;

&lt;p&gt;确定混淆规则&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-keep  保留类和类中的成员，防止它们被混淆或移除。

-keep xxx.xxx.*   一颗星表示不混淆该包下的类，而子包下的类还是会被混淆。
-keep xxx.xxx.**  两颗星表示都不被混淆。
-keep xxx.xxx.** { *; }  表示类内部的方法和变量都不被混淆
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;通用模版&#34;&gt;通用模版&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
#-------------------------------------------基本不用动区域--------------------------------------------
#---------------------------------基本指令区----------------------------------
#代码混淆压缩比，范围为0-7，默认为5。一般不修改
-optimizationpasses 5
# 混合时不使用大小写混合，混合后的类名为小写
-dontusemixedcaseclassnames
# 指定不去忽略非公共库的类
-dontskipnonpubliclibraryclasses
# 指定不去忽略非公共库的类成员
-dontskipnonpubliclibraryclassmembers
# 不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。
-dontpreverify
# 这句话能够使我们的项目混淆后产生映射文件
# 包含有类名-&amp;gt;混淆后类名的映射关系
-verbose
-printmapping proguardMapping.txt
# 指定混淆是采用的算法，后面的参数是一个过滤器
# 这个过滤器是谷歌推荐的算法，一般不做更改
-optimizations !code/simplification/cast,!field/*,!class/merging/*
# 保留Annotation不混淆
-keepattributes *Annotation*,InnerClasses
# 避免混淆泛型
-keepattributes Signature
# 抛出异常时保留代码行号
-keepattributes SourceFile,LineNumberTable

#---------------------------------默认保留区---------------------------------

# 保留我们使用的四大组件，自定义的Application等等这些类不被混淆
# 因为这些子类都有可能被外部调用
-keep public class * extends android.app.Activity
-keep public class * extends android.app.Application
-keep public class * extends android.app.Service
-keep public class * extends android.content.BroadcastReceiver
-keep public class * extends android.content.ContentProvider
-keep public class * extends android.app.backup.BackupAgentHelper
-keep public class * extends android.preference.Preference
-keep public class * extends android.view.View
-keep public class com.android.vending.licensing.ILicensingService

# 保留support下的所有类及其内部类
-keep class android.support.** {*;}

# 保留继承的
-keep public class * extends android.support.v4.**
-keep public class * extends android.support.v7.**
-keep public class * extends android.support.annotation.**

# 保留本地native方法不被混淆
-keepclasseswithmembernames class * {
    native &amp;lt;methods&amp;gt;;
}

# 保留在Activity中的方法参数是view的方法，
# 这样以来我们在layout中写的onClick就不会被影响
-keepclassmembers class * extends android.app.Activity{
    public void *(android.view.View);
}

# 保留枚举类不被混淆
-keepclassmembers enum * {
    public static **[] values();
    public static ** valueOf(java.lang.String);
}

# 保留我们自定义控件（继承自View）不被混淆
-keep public class * extends android.view.View{
    *** get*();
    void set*(***);
    public &amp;lt;init&amp;gt;(android.content.Context);
    public &amp;lt;init&amp;gt;(android.content.Context, android.util.AttributeSet);
    public &amp;lt;init&amp;gt;(android.content.Context, android.util.AttributeSet, int);
}
-keepclasseswithmembers class * {
    public &amp;lt;init&amp;gt;(android.content.Context, android.util.AttributeSet);
    public &amp;lt;init&amp;gt;(android.content.Context, android.util.AttributeSet, int);
}

# 保留Parcelable序列化类不被混淆
-keep class * implements android.os.Parcelable {
  public static final android.os.Parcelable$Creator *;
}
# 保留Serializable序列化的类不被混淆
-keepnames class * implements java.io.Serializable
-keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
        private static final java.io.ObjectStreamField[] serialPersistentFields;
        !static !transient &amp;lt;fields&amp;gt;;
        !private &amp;lt;fields&amp;gt;;
        !private &amp;lt;methods&amp;gt;;
        private void writeObject(java.io.ObjectOutputStream);
        private void readObject(java.io.ObjectInputStream);
        java.lang.Object writeReplace();
        java.lang.Object readResolve();
}

# 保留R下面的资源
-keep class **.R$* {
 *;
}

# 对于带有回调函数的onXXEvent、**On*Listener的，不能被混淆
-keepclassmembers class * {
    void *(**On*Event);
    void *(**On*Listener);
}

#---------------------------------webview------------------------------------
-keepclassmembers class fqcn.of.javascript.interface.for.Webview {
   public *;
}
-keepclassmembers class * extends android.webkit.WebViewClient {
    public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap);
    public boolean *(android.webkit.WebView, java.lang.String);
}
-keepclassmembers class * extends android.webkit.WebViewClient {
    public void *(android.webkit.WebView, jav.lang.String);
}

#--------------实体类---------------#

实体类优雅的混淆

* 在混淆配置文件中添加bean类包名，这样该包下所有的bean类都可以不被混淆了
* -keep public class yourBeanPackageName.**{*;} 
* 使用@keep注解（推荐）

#--------------三方包---------------#


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;常见开源框架混淆&#34;&gt;常见开源框架混淆&lt;/h2&gt;

&lt;p&gt;三方包一般去官网都能找到，实在找不到，你可以使用下面的方法。&lt;/p&gt;

&lt;p&gt;比如融云：&lt;/p&gt;

&lt;p&gt;-dontwarn io.rong.push.**&lt;/p&gt;

&lt;p&gt;-keep class io.rong.push.** {*；}&lt;/p&gt;

&lt;p&gt;如果你不知道第三方的混淆配置，就这样写，没问题的&lt;/p&gt;

&lt;h3 id=&#34;retrofit&#34;&gt;retrofit&lt;/h3&gt;

&lt;p&gt;官网给的混淆配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Platform calls Class.forName on types which do not exist on Android to determine platform.
-dontnote retrofit2.Platform
# Platform used when running on RoboVM on iOS. Will not be used at runtime.
-dontnote retrofit2.Platform$IOS$MainThreadExecutor
# Platform used when running on Java 8 VMs. Will not be used at runtime.
-dontwarn retrofit2.Platform$Java8
# Retain generic type information for use by reflection by converters and adapters.
-keepattributes Signature
# Retain declared checked exceptions for use by a Proxy instance.
-keepattributes Exceptions
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实不完全，retrofit是对Okhttp的封装，而且里面还使用了Gson转换。&lt;/p&gt;

&lt;p&gt;所以需要一个完整的封装。如下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Retrofit
-dontnote retrofit2.Platform
-dontnote retrofit2.Platform$IOS$MainThreadExecutor
-dontwarn retrofit2.Platform$Java8
-keepattributes Signature
-keepattributes Exceptions

# okhttp
-dontwarn okio.**

# Gson
-keep class com.example.testing.retrofitdemo.bean.**{*;} # 自定义数据模型的bean目录

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;volley&#34;&gt;volley&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;## -------------------------------------------
##     volley混淆
## -------------------------------------------
-keep class com.android.volley.** {*;}
-keep class com.android.volley.toolbox.** {*;}
-keep class com.android.volley.Response$* { *; }
-keep class com.android.volley.Request$* { *; }
-keep class com.android.volley.RequestQueue$* { *; }
-keep class com.android.volley.toolbox.HurlStack$* { *; }
-keep class com.android.volley.toolbox.ImageLoader$* { *; }

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;eventbus&#34;&gt;EventBus&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;## ----------------------------------
##     EventBus 相关的混淆配置
## ----------------------------------
-keepattributes *Annotation*
-keepclassmembers class ** {
    @org.greenrobot.eventbus.Subscribe &amp;lt;methods&amp;gt;;
}
-keep enum org.greenrobot.eventbus.ThreadMode { *; }
# Only required if you use AsyncExecutor
-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent {
    &amp;lt;init&amp;gt;(java.lang.Throwable);
}
-keepclassmembers class ** {
    public void onEvent*(**);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;butterknife&#34;&gt;ButterKnife&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;## ----------------------------------
##     butterknife 相关的混淆配置
## ----------------------------------
-dontwarn butterknife.internal.**
-keep class **$$ViewInjector { *; }
-keepnames class * { @butterknife.InjectView *;}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;混淆代码调试&#34;&gt;混淆代码调试&lt;/h2&gt;

&lt;p&gt;混淆后的代码出现错误怎么办呢，如何进行调试？了解一下ProGuard文件。&lt;/p&gt;

&lt;p&gt;混淆之后，会给我们输出一些文件，在gradle方式下是在&lt;project_dir&gt;/build/proguard/目录下，ant是在&lt;project_dir&gt;/bin/proguard目录，eclipse构建在&lt;project_dir&gt;/proguard目录像。
分别有以下文件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;dump.txt 描述apk文件中所有类文件间的内部结构。&lt;/li&gt;
&lt;li&gt;mapping.txt 列出了原始的类，方法，和字段名与混淆后代码之间的映射。&lt;/li&gt;
&lt;li&gt;seeds.txt 列出了未被混淆的类和成员&lt;/li&gt;
&lt;li&gt;usage.txt 列出了从apk中删除的代码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我们发布的release版本的程序出现bug时，可以通过以上文件（特别时mapping.txt）文件找到错误原始的位置，进行bug修改。同时，可能一开始的proguard配置有错误，也可以通过错误日志，根据这些文件，找到哪些文件不应该混淆，从而修改proguard的配置。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Gradle从2.1升级到3.3具体的一些坑</title>
      <link>https://guixiaoyuan.github.io/post/2018-03-22/</link>
      <pubDate>Thu, 22 Mar 2018 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2018-03-22/</guid>
      <description>&lt;p&gt;最近维护原有的老项目的时候，发现gradle版本居然是2.1版本，难怪我说编译需要花费5分钟！！！尤其是现在的gradle稳定版本已经4.1+的情况下，显得更慢。&lt;/p&gt;

&lt;p&gt;本着时间就是金钱的理念，开启了我的升级填坑之旅！、
&lt;/p&gt;

&lt;p&gt;当然升级不能走的太快，太快容易扯着蛋。稳妥起见，决定先升级到3.3。（其实是公司其他项目都用3.3版本，我也很想升级到最新版本，体验快的感觉啊）&lt;/p&gt;

&lt;p&gt;第一步就是在最外层的build.gradle文件中修改版本号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;classpath &#39;com.android.tools.build:gradle:2.1.0&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;神马，版本号怎么对应？&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.android.com/studio/releases/gradle-plugin.html#revisions&#34;&gt;谷歌官方版本对应说明，需要翻墙哦&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对应下来，gradle3.3版本就是2.3.3&lt;/p&gt;

&lt;h2 id=&#34;第一个坑&#34;&gt;第一个坑&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Error:A problem was found with the configuration of task &#39;:app:packageRelease&#39;.  
&amp;gt; File &#39;E:\project-gitosc\pet\Pet-Android\Pet-Bulter\app\build\intermediates\res\resources-release-stripped.ap_&#39; specified for property &#39;resourceFile&#39; does not exist.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原因：build.gradle（app）文件中，代码混淆和移除无用的资源文件有一个为false。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解决方案：两者都必须为true&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//启用代码混淆  
minifyEnabled true  

//移除无用的资源文件  
shrinkResources true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第二个坑&#34;&gt;第二个坑&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Error:All flavors must now belong to a named flavor dimension.Learn more at https://d.android.com/r/tools/flavorDimensions-missing-error-message.html 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;原因：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Plugin 3.0.0之后有一种自动匹配消耗库的机制，便于debug variant 自动消耗一个库，然后就是必须要所有的flavor 都属于同一个维度。
为了避免flavor 不同产生误差的问题，应该在所有的库模块都使用同一个foo尺寸。具体的信息内容可以去看错误提示中的官网消息。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;解决方案：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;在主app的build.gradle里面的
 defaultConfig {
 targetSdkVersion：***
 minSdkVersion ：***
 versionCode：***
 versionName ：***
//版本名后面添加一句话，意思就是flavor dimension 它的维度就是该版本号，这样维度就是都是统一的了
flavorDimensions &amp;quot;versionCode&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第三个坑&#34;&gt;第三个坑&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Unable to load class ‘org.gradle.api.internal.component.Usage’.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;原因&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;novoda:bintray 版本老旧。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;解决方案&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;修改项目根目录下的build.gradle的版本号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buildscript {
    repositories {
        jcenter()
        google()
    }
    dependencies {
        ...
        classpath &#39;com.novoda:bintray-release:0.5.0&#39;//修改此处版本号为 0.5.0---修改之前是0.3.4
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第四个坑&#34;&gt;第四个坑&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Error:Could not resolve all files for configuration &#39;:app:xxxxxxxDebugCompileClasspath&#39;.

Failed to transform file &#39;commons-lang-2.4.jar&#39; to match attributes {artifactType=android-classes} using transform JarTransform Transform output file xxxxxxx/xxxxxxx/xxxxxxx/app/commons-lang-2.4.jar does not exist.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;原因 jar包寻找不到。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;仔细一看项目中引入jar包的方式还是很古老的&lt;/p&gt;

&lt;p&gt;compile files(&amp;lsquo;libs/mta-sdk-1.6.2.jar&amp;rsquo;)&lt;/p&gt;

&lt;p&gt;新版本不识别。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;解决方案&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;删除原有引入方式，重新引入&lt;/p&gt;

&lt;p&gt;compile fileTree(include: [&amp;rsquo;*.jar&amp;rsquo;], dir: &amp;lsquo;libs&amp;rsquo;)&lt;/p&gt;

&lt;h2 id=&#34;第五个坑&#34;&gt;第五个坑&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;Cannot set the value of read-only property ‘outputFile’ ） 
Error:(56, 0) Cannot set the value of read-only property ‘outputFile’ for ApkVariantOutputImpl_Decorated{apkData=Main{type=MAIN, fullName=debug, filters=[]}} of type com.android.build.gradle.internal.api.ApkVariantOutputImpl.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;原因，&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;自定义输出apk名字的语法出现改变。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;解决方案。如下修改。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;//            applicationVariants.all { variant -&amp;gt;
//                variant.outputs.each { output -&amp;gt;
//                    def outputFile = output.outputFile
//                    if (outputFile != null &amp;amp;&amp;amp; outputFile.name.endsWith(&#39;.apk&#39;)) {
//                        def fileName = &amp;quot;你自定义.apk&amp;quot;
//                        output.outputFile = new File(outputFile.parent, fileName)
//                    }
//                }
//            }
            android.applicationVariants.all { variant -&amp;gt;
                variant.outputs.all {
                    outputFileName = &amp;quot;你自定义.apk&amp;quot;
                }
            }
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>关于String的一点知识</title>
      <link>https://guixiaoyuan.github.io/post/2017-09-21/</link>
      <pubDate>Thu, 21 Sep 2017 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2017-09-21/</guid>
      <description>&lt;p&gt;相信大部分准备过java面试的同学都知道Java中的String是final修饰,不可变的。可是只知道是什么，不知道为什么是一件非常危险的事情。因为任何事情都没有绝对。&lt;/p&gt;

&lt;p&gt;我们先看看什么是不可变对象。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;什么是不可变对象&#34;&gt;什么是不可变对象？&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;如果一个对象，在创建完成之后，不能在改变他的状态。（包括内部成员变量，基本数据类型。引用类型的变量不能指向其他对象，引用类型指向的对象的状态）对象则认为不可改变。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于Java中的String不可变的原因，具体可以参考下面这篇文章。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/zhangjg_blog/article/details/18319521&#34;&gt;Java中的String不可变的原因&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文中源码一直分析到了1.7，但是1.8之后，String源码又改动。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final class String
    implements java.io.Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence {

    // The associated character storage is managed by the runtime. We only
    // keep track of the length here.
    //
    // private final char value[];
    private final int count;

    /** Cache the hash code for the string */
    private int hash; // Default to 0
    ....
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释中我们可以看到，已经把字符存储放到runtime里面去了。而且内部修改字符串，也不再是简单的new String出来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public String replace(char oldChar, char newChar) {
    String replaced = this;
    if (oldChar != newChar) {
        for (int i = 0; i &amp;lt; count; ++i) {
            if (charAt(i) == oldChar) {
                if (replaced == this) {
                    replaced = StringFactory.newStringFromString(this);
                }
                replaced.setCharAt(i, newChar);
            }
        }
    }
    return replaced;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;采用了StringFactory.newStringFromString(),这个是native方法。上述文章中提到了利用反射修改不可访问的value，从而使不可变String，变成可变String。貌似在1.8中已经被封杀了。&lt;/p&gt;

&lt;h3 id=&#34;string类不可变的好处&#34;&gt;String类不可变的好处：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;字符串池实现的前提。在运行时节约heap空间。不同字符串变量都指向同一个字符串。&lt;/li&gt;
&lt;li&gt;保障安全。直接影响：账号，密码等都以字符串的形式传递；隐形影响：HashSet，存储String内容，如果可变，破坏键值的唯一性。&lt;/li&gt;
&lt;li&gt;多线程安全。&lt;/li&gt;
&lt;li&gt;缓存Hashcode，高效。String不可变，hashcode就是一个定值。不需要重新计算，所以作为map中的键，处理速度会更快。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Android热更新</title>
      <link>https://guixiaoyuan.github.io/post/2017-08-26/</link>
      <pubDate>Sat, 26 Aug 2017 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2017-08-26/</guid>
      <description>&lt;p&gt;项目场景：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;紧急发现了一个bug，影响用户体验，阻断项目流程。这个时候，只能紧急发布一个强制更新的新版本，让用户升级。&lt;/li&gt;
&lt;li&gt;最近百团大战开始。需要增加一个活动弹窗入口，越快越好。这个时候，只能紧急发布一个强制更新的新版本，让用户升级。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;存在需求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;可不可以不让用户重新安装就可以解决上述场景？
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;什么是热更新&#34;&gt;什么是热更新：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;让应用能够在无需重新安装的情况实现更新，帮助应用快速建立动态修复能力。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的定义来看，热补丁节省Android大量应用市场发布的时间。同时用户也无需重新安装，只要上线就能无感知的更新。&lt;/p&gt;

&lt;h3 id=&#34;热更新的原理&#34;&gt;热更新的原理：&lt;/h3&gt;

&lt;p&gt;现在市面上主流的几大热更新技术：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;淘宝 Dexposed&lt;/li&gt;
&lt;li&gt;支付宝 AndFix&lt;/li&gt;
&lt;li&gt;Qzone 超级热补丁&lt;/li&gt;
&lt;li&gt;微信 Tinker&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;dexposed&#34;&gt;Dexposed&lt;/h4&gt;

&lt;p&gt;基于 Xposed 实现的无侵入的运行时 AOP (Aspect-oriented Programming)  框架，可以实现在线修复 Bug，修复粒度方法级别，这也就意味着我们没有办法进行类的增减操作。而且由于对 ART 虚拟机不支持，导致其对 Android 5.0、6.0 均不支持，使用局限性太大。&lt;/p&gt;

&lt;h3 id=&#34;andfix&#34;&gt;AndFix&lt;/h3&gt;

&lt;p&gt;native hook 方式，其核心部分在 JNI 层对方法进行替换，替换有问题的方法,修复粒度方法级别，无法在类中新增和删减字段，可以做到即时生效。也就是运行时生效。但是因为它的核心部分在JNI，所以会出现很多适配兼容的问题。因为国内的rom厂商多才多艺.&lt;/p&gt;

&lt;h3 id=&#34;超级热补丁&#34;&gt;超级热补丁&lt;/h3&gt;

&lt;p&gt;使用新的 ClassLoader 加载 patch.dex，hack 默认的 ClassLoader，替换有问题的类，修复粒度类级别，一般无法做到即时生效，需要在应用下一次启动时生效。但是在art虚拟机中，如果改变了类变量，和方法名，有可能导致内存错乱的问题，没有开源这个项目。但在github上的Nuwa采用了相同的方式，这个是开源。&lt;/p&gt;

&lt;h3 id=&#34;tinker&#34;&gt;Tinker&lt;/h3&gt;

&lt;p&gt;dex 文件全量替换，基于 DexDiff 技术，对比修复前后的 dex 文件，生成 patch.dex，再根据 patch.dex 更新有问题的 dex 文件。简单来说，在编译时通过新旧两个Dex生成差异patch.dex。在运行时，将差异patch.dex重新跟原始安装包的旧Dex还原为新的Dex。这个过程可能比较耗费时间与内存，所以我们是单独放在一个后台进程:patch中。为了补丁包尽量的小，微信自研了DexDiff算法，它深度利用Dex的格式来减少差异的大小。&lt;/p&gt;

&lt;h3 id=&#34;热更新方案的比较&#34;&gt;热更新方案的比较：&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tables&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Tinker&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Qzone&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Andfix&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Dexposed&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;类替换&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;lib替换&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;资源替换&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;全平台支持&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;即时生效&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;yes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;性能损耗&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较小&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较大&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较小&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较小&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;补丁包大小&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较小&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较大&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;一般&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;一般&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;开发透明&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;复杂度&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较低&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较低&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;复杂&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;复杂&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gradle支持&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;no&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;接口文档&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;丰富&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;一般&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;一般&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较少&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;占rom体积&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较大&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较小&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较小&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;较小&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;成功率&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;较好&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;最高&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;一般&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;一般&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;热更新的使用场景&#34;&gt;热更新的使用场景：&lt;/h3&gt;

&lt;p&gt;热补丁技术也可以理解为一个动态修改代码与资源的通道，它适合于修改量较少的情况。&lt;/p&gt;

&lt;p&gt;我们看一下微信的版本升级的情况：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tables&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;普通升级&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;布丁升级&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;数据大小&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;33M&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;145K&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;更新速度&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;10天&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1天（70%）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;自动升级&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;wifi&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;移动网络&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以Android用户的升级习惯，即使是相对活跃的微信也需要10天以上的时间去覆盖50%的用户。使用补丁技术，我们能做到1天覆盖70%以上。这也是基于补丁体积较小，可以直接使用移动网络下载更新。&lt;/p&gt;

&lt;h3 id=&#34;热更新使用限制&#34;&gt;热更新使用限制&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;补丁只能针对单一客户端版本，随着版本差异变大补丁体积也会增大；&lt;/li&gt;
&lt;li&gt;补丁不能支持所有的修改，例如AndroidManifest；&lt;/li&gt;
&lt;li&gt;补丁无论对代码还是资源的更新成功率都无法达到100%。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;如何在一个项目中增加热更新功能&#34;&gt;如何在一个项目中增加热更新功能？&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在工程目录 build.gradle 文件中添加插件依赖。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        // tinkersupport插件，其中latest.release指代最新版本号，也可以指定明确的版本号，例如1.0.8
        classpath &amp;quot;com.tencent.bugly:tinker-support:latest.release&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在app module 下的build.gradle 文件中添加 配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dependencies {
      compile &amp;quot;com.android.support:multidex:1.0.1&amp;quot; 
      compile &#39;com.tencent.bugly:crashreport_upgrade:latest.release&#39;
}
// 依赖插件脚本
apply from: &#39;tinker-support.gradle&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在同级目录下创建 tinker-support.gradle&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apply plugin: &#39;com.tencent.bugly.tinker-support&#39;

def bakPath = file(&amp;quot;${buildDir}/bakApk/&amp;quot;)

/**
 * 此处填写每次构建生成的基准包目录
 */
def baseApkDir = &amp;quot;app-0912-17-04-44&amp;quot;
/**
 * 对于插件各参数的详细解析请参考
 */
tinkerSupport {

    // 开启tinker-support插件，默认值true
    enable = true

    //自动生成tinkerId，无须关注此。默认为false
    //autoGenerateTinkerId = true

    tinkerEnable = true

    // 指定归档目录，默认值当前module的子目录tinker
    autoBackupApkDir = &amp;quot;${bakPath}&amp;quot;

    // 是否启用覆盖tinkerPatch配置功能，默认值false
    // 开启后tinkerPatch配置不生效，即无需添加tinkerPatch
    overrideTinkerPatchConfiguration = true

    // 编译补丁包时，必需指定基线版本的apk，默认值为空
    // 如果为空，则表示不是进行补丁包的编译
    // @{link tinkerPatch.oldApk }
    baseApk = &amp;quot;${bakPath}/${baseApkDir}/com.nongfenqi.sherlock-release-v2.3.2_32.apk&amp;quot;
    // 对应tinker插件applyMapping
    baseApkProguardMapping = &amp;quot;${bakPath}/${baseApkDir}/app-release-mapping.txt&amp;quot;

    // 对应tinker插件applyResourceMapping
    baseApkResourceMapping = &amp;quot;${bakPath}/${baseApkDir}/app-release-R.txt&amp;quot;

    // 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性
    tinkerId = &amp;quot;2.3.2-0912-patch&amp;quot;

    // 构建多渠道补丁时使用
    // buildAllFlavorsDir = &amp;quot;${bakPath}/${baseApkDir}&amp;quot;

    // 是否启用加固模式，默认为false.(tinker-spport 1.0.7起支持）
    // isProtectedApp = true

    // 是否开启反射Application模式
    enableProxyApplication = false

}

/**
 * 一般来说,我们无需对下面的参数做任何的修改
 * 对于各参数的详细介绍请参考:
 * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97
 */
tinkerPatch {
    //oldApk =&amp;quot;${bakPath}/${appName}/app-release.apk&amp;quot;
    tinkerEnable = true
    ignoreWarning = false
    useSign = true
    dex {
        dexMode = &amp;quot;jar&amp;quot;
        pattern = [&amp;quot;classes*.dex&amp;quot;]
        loader = []
    }
    lib {
        pattern = [&amp;quot;lib/*/*.so&amp;quot;]
    }

    res {
        pattern = [&amp;quot;res/*&amp;quot;, &amp;quot;r/*&amp;quot;, &amp;quot;assets/*&amp;quot;, &amp;quot;resources.arsc&amp;quot;, &amp;quot;AndroidManifest.xml&amp;quot;]
        ignoreChange = []
        largeModSize = 100
    }

    packageConfig {
    }
    sevenZip {
        zipArtifact = &amp;quot;com.tencent.mm:SevenZip:1.1.10&amp;quot;
//        path = &amp;quot;/usr/local/bin/7za&amp;quot;
    }
    buildConfig {
        keepDexApply = false
        //tinkerId = &amp;quot;1.0.1-base&amp;quot;
        //applyMapping = &amp;quot;${bakPath}/${appName}/app-release-mapping.txt&amp;quot; //  可选，设置mapping文件，建议保持旧apk的proguard混淆方式
        //applyResourceMapping = &amp;quot;${bakPath}/${appName}/app-release-R.txt&amp;quot; // 可选，设置R.txt文件，通过旧apk文件保持ResId的分配
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;权限配置以及activity配置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;uses-permission android:name=&amp;quot;android.permission.READ_PHONE_STATE&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.INTERNET&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_NETWORK_STATE&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_WIFI_STATE&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.READ_LOGS&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.WRITE_EXTERNAL_STORAGE&amp;quot; /&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.READ_EXTERNAL_STORAGE&amp;quot;/&amp;gt;


&amp;lt;activity
    android:name=&amp;quot;com.tencent.bugly.beta.ui.BetaActivity&amp;quot;
    android:theme=&amp;quot;@android:style/Theme.Translucent&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;混淆配置&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;        -dontwarn com.tencent.bugly.**
        -keep public class com.tencent.bugly.**{*;}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;</description>
    </item>
    
    <item>
      <title>Android 触摸机制</title>
      <link>https://guixiaoyuan.github.io/post/2016-03-02/</link>
      <pubDate>Wed, 02 Mar 2016 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2016-03-02/</guid>
      <description>&lt;p&gt;android开发，涉及到自定义view的时机会非常的多，完成一个非常优质的view，view必须和用户又一个非常良好的交互。view的事件处理就是一个很重要的环节。&lt;/p&gt;

&lt;p&gt;本文是对view有一定基础的总结。
&lt;/p&gt;

&lt;h1 id=&#34;android-触摸机制&#34;&gt;Android 触摸机制&lt;/h1&gt;

&lt;p&gt;在理解事件处理机制之前，我们先理解一下，view和viewGroup的异同。&lt;/p&gt;

&lt;h3 id=&#34;view&#34;&gt;view&lt;/h3&gt;

&lt;p&gt;view 在官方文档上是这么写的：This class represents the basic building block for user interface components.也就是说这个类代表用户界面组件的基本构建块。所有在ui界面上看到的东西本质上都是view.或者是从View继承过来的。&lt;/p&gt;

&lt;p&gt;比如常见的控件，textview，button，都是继承view。&lt;/p&gt;

&lt;h3 id=&#34;viewgroup&#34;&gt;viewGroup&lt;/h3&gt;

&lt;p&gt;ViewGroup在官方文档上是这么写的：The ViewGroup subclass is the base class for layouts, which are invisible containers that hold other Views (or other ViewGroups) and define their layout properties.简单来说，viewGroup就是布局。而布局我们最常见的也就是linearLayout，RealtiveLayout,FrameLayout等等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;从类结构，层级上来看,view 是包含 textview，viewGroup的。

view是根，其他的都是衍生出来的
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;从界面的包含关系上来看,viewGroup 是包含 view，viewGroup的

viewGroup是根，其他的都是附加在viewGroup上的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;理解之后，我们从操作上知道，当我们的手，去触摸屏幕的时候，界面会随着我们的操作而进行不同的交互。&lt;/p&gt;

&lt;p&gt;触摸的时候，就是一个touch事件处理的过程。&lt;/p&gt;

&lt;h3 id=&#34;一个触摸事件的具体分发流程&#34;&gt;一个触摸事件的具体分发流程&lt;/h3&gt;

&lt;p&gt;当我们的手指点击屏幕的时候，会产生一系列具体的事件。move ,down ,up。
我们的activity 会第一个接受到事件。&lt;/p&gt;

&lt;p&gt;调用 dispatchTouchEvent() 事件。返回值有三种 true,false，super。&lt;/p&gt;

&lt;p&gt;true,false 表示touch事件在activity消费掉，不下发给view。&lt;/p&gt;

&lt;p&gt;super 表示下发给ViewGroup处理。具体流程看下图。&lt;/p&gt;

&lt;p&gt;这边先重点看一下，为什么activty的点击事件，传递到了viewGroup层。&lt;/p&gt;

&lt;p&gt;我们首先看一下源码(基于sdk-28)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
/**
     * Called to process touch screen events.  You can override this to
     * intercept all touch screen events before they are dispatched to the
     * window.  Be sure to call this implementation for touch screen events
     * that should be handled normally.
     *
     * @param ev The touch screen event.
     *
     * @return boolean Return true if this event was consumed.
     */
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();
        }
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true;
        }
        return onTouchEvent(ev);
    }
    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很容易看到getWindow,这样子很容易让我们联想到和view有关。那我们看一下getWindow.superDispatchTouchEvent()做了什么。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /**
     * Used by custom windows, such as Dialog, to pass the touch screen event
     * further down the view hierarchy. Application developers should
     * not need to implement or call this.
     *
     */
    public abstract boolean superDispatchTouchEvent(MotionEvent event);
    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它是window里面的一个抽象方法。传递touch screen event。而我们知道activity里面有一个phoneWindow,所以追踪phoneWindow.superDispatchTouchEvent()&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; @Override
    public boolean superDispatchTouchEvent(MotionEvent event) {
        return mDecor.superDispatchTouchEvent(event);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到了mDecor，大概我们就知道怎么传递下去的了。&lt;/p&gt;

&lt;p&gt;先看下mDecor的定义。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; // This is the top-level view of the window, containing the window decor.
    private DecorView mDecor;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就是我们手机屏幕的最外层view。然后它分发给里面的view，最后我们的view就拿到了传递事件。&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;https://guixiaoyuan.github.io/media/android_touch.png&#34; alt=&#34;example&#34; /&gt;
    
    
&lt;/figure&gt;



&lt;p&gt;&lt;img src=&#34;https://github.com/guixiaoyuan/guixiaoyuan.github.io/blob/master/static/media/android_touch.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/hgt312/hgt312.github.io/master/post/img/your_category/note_number/your_img.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;touch事件&#34;&gt;touch事件&lt;/h3&gt;

&lt;p&gt;Touch事件分发中只有两个主角:ViewGroup和View。Activity的Touch事件事实上是调用它内部的ViewGroup的Touch事件，可以直接当成ViewGroup处理。&lt;/p&gt;

&lt;p&gt;简单的了解一下Android 处理触摸事件主要涉及到几个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;onInterceptTouchEvent(),（只有viewGroup有）

dipatchTouchEvent(), onTouchEvent(), onTouch()。
view和viewGroup都有
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;onInterceptTouchEvent（）从字面上看都是拦截用的。
dipatchTouchEvent（） 是分发。
onTouchEvent(), onTouch() 是处理触摸的。&lt;/p&gt;

&lt;p&gt;通过上面我们知道，view是没有拦截方法的，也就是它没有办法往下传递。所以就没有中断接受的概念。&lt;/p&gt;

&lt;p&gt;其实在view中，dispatchTouchEvent（）没什么意思。因为，它分发这个事件，其实就是给自己处理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;所以，一般情况下，我们不该在普通View内重写
dispatchTouchEvent方法，因为它并不执行分发逻辑。
当Touch事件到达View时，我们该做的就是是否在
onTouchEvent事件中处理它。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ontouch-和ontouchevent-的关系&#34;&gt;onTouch()和onTouchEvent()的关系&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public boolean dispatchTouchEvent(MotionEvent event) {
       
       	...

        if (onFilterTouchEventForSecurity(event)) {
            if ((mViewFlags &amp;amp; ENABLED_MASK) == ENABLED &amp;amp;&amp;amp; handleScrollBarDragging(event)) {
                result = true;
            }
            //noinspection SimplifiableIfStatement
            ListenerInfo li = mListenerInfo;
            if (li != null &amp;amp;&amp;amp; li.mOnTouchListener != null
                    &amp;amp;&amp;amp; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED
                    &amp;amp;&amp;amp; li.mOnTouchListener.onTouch(this, event)) {
                result = true;
            }

            if (!result &amp;amp;&amp;amp; onTouchEvent(event)) {
                result = true;
            }
        }

		...

        return result;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先看view关于分发的源码，我们知道onTouchLister的优先级高于onTouchEvent事件。所以onTouch()比onTouchEvent(）先调用。&lt;/p&gt;

&lt;p&gt;onTouch事件消费完成，返回ture的时候，onTouchEvent()就不会调用。&lt;/p&gt;

&lt;p&gt;因为Button的performClick是利用onTouchEvent实现，假若onTouchEvent没有被调用到，那么Button的Click事件也无法响应。&lt;/p&gt;

&lt;p&gt;onTouchListener的onTouch方法优先级比onTouchEvent高，会先触发。&lt;/p&gt;

&lt;p&gt;假如onTouch方法返回false会接着触发onTouchEvent，反之onTouchEvent方法不会被调用。&lt;/p&gt;

&lt;p&gt;内置诸如click事件的实现等等都基于onTouchEvent，假如onTouch返回true，这些事件将不会被触发。&lt;/p&gt;

&lt;h3 id=&#34;触摸事件具体调用顺序&#34;&gt;触摸事件具体调用顺序&lt;/h3&gt;

&lt;p&gt;默认情况下，我们的动作都是从最外层传递到最里层的，一般简单的来说，也就是从ViewGroup到view。而实际处理，则是从最里层开始，一层层到外层。也就是view到ViewGroup。&lt;/p&gt;

&lt;p&gt;首先会调用最外层的dispatchTouchEvent()，其实这个方法就是分发事件，返回false，表示此层不接受这个动作，继续发送给下层。如果是true，则不传递动作给下面了。如果是viewGroup的话，接下来会调用onInterceptTouchEvent(),此方法用于拦截动作，返回true，拦截成功，false，不拦截。&lt;/p&gt;

&lt;p&gt;动作传递到下一层之后，会继续重复上面的动作。直到传递到最里层，也就是上图的叶子节点。这个时候，会调用onTouchEvent事件。如果返回false，表示继续往上传递，会调用上层的onTouchEvent()的事件，重复一直到执行到最上层。也就是上图的根节点。&lt;/p&gt;

&lt;p&gt;在这里有一件事情要注意，也就是，只有当viewGroup里面的所有子控件返回的都是false，才会执行viewGroup的onTouchEvent（）。&lt;/p&gt;

&lt;p&gt;在目前的情况看来， 似乎只要我们把所有的onTouchEvent都返回false，就能保证所有的子控件都响应本次Touch事件了。但必须要说明的是，这里的Touch 事件，只限于Acition_Down事件，即触摸按下事件,而Aciton_UP和Action_MOVE却不会执行。事实上，一次完整的Touch事 件，应该是由一个Down、一个Up和若干个Move组成的。Down方式通过dispatchTouchEvent分发，分发的目的是为了找到真正需要 处理完整Touch请求的View。当某个View或者ViewGroup的onTouchEvent事件返回true时，便表示它是真正要处理这次请求 的View，之后的Aciton_UP和Action_MOVE将由它处理。当所有子View的onTouchEvent都返回false时，这次的 Touch请求就由根ViewGroup，即Activity自己处理了。&lt;/p&gt;

&lt;h3 id=&#34;总结一下&#34;&gt;总结一下&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Touch 事件分发中只有两个主角:ViewGroup和View。ViewGroup包含onInterceptTouchEvent、 dispatchTouchEvent、onTouchEvent三个相关事件。View包含dispatchTouchEvent、 onTouchEvent两个相关事件。其中ViewGroup又继承于View。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ViewGroup和View组成了一个树状结构，根节点为Activity内部包含的一个ViwGroup。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;触摸事件由Action_Down、Action_Move、Aciton_UP组成，其中一次完整的触摸事件中，Down和Up都只有一个，Move有若干个，可以为0个。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当Acitivty接收到Touch事件时，将遍历子View进行Down事件的分发。ViewGroup的遍历可以看成是递归的。分发的目的是为了找到真正要处理本次完整触摸事件的View，这个View会在onTouchuEvent结果返回true。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当某个子 View返回true时，会中止Down事件的分发，同时在ViewGroup中记录该子View。接下去的Move和Up事件将由该子View直接进行 处理。由于子View是保存在ViewGroup中的，多层ViewGroup的节点结构时，上级ViewGroup保存的会是真实处理事件的View所 在的ViewGroup对象:如ViewGroup0-ViewGroup1-TextView的结构中，TextView返回了true，它将被保存在 ViewGroup1中，而ViewGroup1也会返回true，被保存在ViewGroup0中。当Move和UP事件来时，会先从 ViewGroup0传递至ViewGroup1，再由ViewGroup1传递至TextView。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当 ViewGroup中所有子View都不捕获Down事件时，将触发ViewGroup自身的onTouch事件。触发的方式是调用 super.dispatchTouchEvent函数，即父类View的dispatchTouchEvent方法。在所有子View都不处理的情况 下，触发Acitivity的onTouchEvent方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;onInterceptTouchEvent有两个作用：1.拦截Down事件的分发。2.中止Up和Move事件向目标View传递，使得目标View所在的ViewGroup捕获Up和Move事件。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>浅谈Android ANR</title>
      <link>https://guixiaoyuan.github.io/post/2016-02-23/</link>
      <pubDate>Tue, 23 Feb 2016 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2016-02-23/</guid>
      <description>&lt;p&gt;使用android手机的时候，有时候会出现卡屏，无法动弹的情况。本文就简单的说明一下程序无响应的问题。
&lt;/p&gt;

&lt;h1 id=&#34;浅谈android-anr&#34;&gt;浅谈Android ANR&lt;/h1&gt;

&lt;p&gt;ANR is Application Not Responding.&lt;/p&gt;

&lt;h2 id=&#34;现象&#34;&gt;现象&lt;/h2&gt;

&lt;p&gt;用户感知为程序长时间无法响应，Android系统自身会弹出一个对话框，告知需要等待，还是杀死程序。&lt;/p&gt;

&lt;h2 id=&#34;原因&#34;&gt;原因&lt;/h2&gt;

&lt;p&gt;应用程序主线程在超时时间内对输入事件没有处理完毕，或者对特定操作没有执行完毕，就会出现ANR。&lt;/p&gt;

&lt;h2 id=&#34;anr的类型&#34;&gt;ANR的类型&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;KeyDispatchTimeout(5 seconds)
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主要类型，系统会显示对话框提示。按键或触摸事件在特定时间内无响应。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  可能出现的两种情况
  1，用户输入事件处理超时；2，窗口获取焦点超时
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;BroadcastTimeout(10 seconds)  &lt;/p&gt;

&lt;p&gt;系统仅仅输出log而已，BroadcastReceiver在特定时间内无法处理完成&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ServiceTimeout(20 seconds)  &lt;/p&gt;

&lt;p&gt;系统仅仅输出log而已，Service在特定时间内无法处理完成&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ContentProvider相关操作执行超时，（I/O耗时操作）,在UI线程中进行网络操作，也容易引发ANR。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;解决套路&#34;&gt;解决套路&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;第一种情况&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;Log提示语：Reason:Input dispatching timed out(Waiting because the focused window has not finished processing the input events that were previously delivered to it);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;产生这种ANR的前提是要有输入事件，如果用户没有触发任何输入事件，即使是主线程阻塞，也不会产生ANR，因为InputDispatcer没有分发事件给应用程序，所以不会检测处理超时，以及报告ANR。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第二种情况：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;Log提示语：Reason:Input dispatching timed out(Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如何避免KeyDispatchTimeout&lt;/p&gt;

&lt;p&gt;1：UI线程尽量只做跟UI相关的工作&lt;/p&gt;

&lt;p&gt;2：耗时的工作（比如数据库操作，I/O，连接网络或者别的有可能阻碍UI线程的操作）把它放入单独的线程处理&lt;/p&gt;

&lt;p&gt;3：尽量用Handler来处理UIthread和别的thread之间的交互&lt;/p&gt;

&lt;h2 id=&#34;android的一些耗时操作&#34;&gt;android的一些耗时操作&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;数据库操作。数据库操作尽量采用异步方法做处理。&lt;/li&gt;
&lt;li&gt;初始化的数据和控件太多。&lt;/li&gt;
&lt;li&gt;频繁的创建线程或者其他大对象。&lt;/li&gt;
&lt;li&gt;加载过大数据和图片&lt;/li&gt;
&lt;li&gt;对大树据排序和循环操作&lt;/li&gt;
&lt;li&gt;过多的广播和滥用广播&lt;/li&gt;
&lt;li&gt;大树据的传递和共享&lt;/li&gt;
&lt;li&gt;访问网络&lt;/li&gt;
&lt;li&gt;避免在循环中创建对象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;最后一点小体会&#34;&gt;最后一点小体会&lt;/h2&gt;

&lt;p&gt;Thread.sleep();表示主动休眠，无论你设置为多长时间，只要你在睡眠的时候，不进行其他的操作，都不会造成anr。&lt;/p&gt;

&lt;p&gt;如果你在代码中，直接引用Thread, 在ui线程中，就是ui thread。在子线程中，就是子线程 thread。&lt;/p&gt;

&lt;p&gt;直接new Thread().start().这个就是创建一个子线程，ui线程和子线程会一起执行。如果对同一个资源进行操作，所以才会产生死锁现象&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Android 如何根据XML文件读取drawable资源</title>
      <link>https://guixiaoyuan.github.io/post/2016-01-06/</link>
      <pubDate>Wed, 06 Jan 2016 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2016-01-06/</guid>
      <description>&lt;p&gt;问题提出的背景：自己在做launcher的新功能，摇一摇切换壁纸的时候。需要动态获取壁纸的id，然后填充到布局上。这样在后期维护的时候，就不需要过多的改动代码，直接增减图片，以及在配置文件（wallpapers.xml）中修改就好了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一种做法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在XML文件中声明资源ID数组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;array name = &amp;quot;drawer_icon_normal&amp;quot;&amp;gt;
        &amp;lt;item&amp;gt;@drawable/ic_drawer_home_normal&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;@drawable/ic_drawer_follow_normal&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;@drawable/ic_drawer_collect_normal&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;@drawable/ic_drawer_register_normal&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;@drawable/ic_drawer_explore_normal&amp;lt;/item&amp;gt;
    &amp;lt;/array&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后要获取ID需要通过TypedArray来获取。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TypedArray array = context.getResources().obtainTypedArray(R.array.drawer_icon_normal);
    for (int i = 0; i &amp;lt; array.length(); i++) {
        drawables_normal[i] = array.getResourceId(i$, R.drawable.default_profile);//后面的drawable文件是找不到资源加载的的文件
    }
    array.recycle();
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;第二种做法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;xml文件中声明有所不同。没有了@drawable，所以在获取图片名字的时候，直接是名字，而不是路径。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;array name = &amp;quot;drawer_icon_normal&amp;quot;&amp;gt;
        &amp;lt;item&amp;gt;ic_drawer_home_normal&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;ic_drawer_follow_normal&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;ic_drawer_collect_normal&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;ic_drawer_register_normal&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;ic_drawer_explore_normal&amp;lt;/item&amp;gt;
    &amp;lt;/array&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后获取Id的方法如下：&lt;/p&gt;

&lt;p&gt;获取图片的文件名的方法：&lt;/p&gt;

&lt;p&gt;String[] extras = getContext.getResources().getStringArray(R.array.drawer_icon_normal);&lt;/p&gt;

&lt;p&gt;packageName的获取方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;getContext.getResources().getResourcesPackageName(R.array.drawer_icon_normal);
int resId =  getContext().getResources().getIdentifier(&amp;quot;图片的文件名&amp;quot;，&amp;quot;文件的类型，如drawable&amp;quot;，&amp;quot;文件的packageName  一般为getContext.getPackageName()&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>ViewHolder 小结</title>
      <link>https://guixiaoyuan.github.io/post/2015-12-23/</link>
      <pubDate>Wed, 23 Dec 2015 00:00:00 UTC</pubDate>
      <author>Xiaoyuan Gui</author>
      <guid>https://guixiaoyuan.github.io/post/2015-12-23/</guid>
      <description>&lt;p&gt;adapter用的很多，android 5.0之后，采用recycleview来取代之前的listview。其中最大的一点就是让大家习惯于用viewholder.自己小结一下viewHolder的好处。&lt;/p&gt;

&lt;p&gt;根据android对view的绘制原理，我们可以看到每一次对画布中view的寻找，是自上而下的，所以每一次findviewbyId的消耗非常大。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;所以根据为了减少不必要的资源浪费，我们直接将找到的id资源，暂存起来。也就是放进ViewHolder中。&lt;/p&gt;

&lt;p&gt;viewHolder不是一个缓存类，只是一个静态类。&lt;/p&gt;

&lt;h3 id=&#34;2-convertview中的tag&#34;&gt;2.convertView中的TAG：&lt;/h3&gt;

&lt;p&gt;(1).Tag不像ID是用标示view的。Tag从本质上来讲是就是相关联的view的额外的信息。它们经常用来存储一些view的数据，这样做非常方便而不用存入另外的单独结构。&lt;/p&gt;

&lt;p&gt;(2). 首先我们要知道setTag方法是干什么的：他是给View对象的一个标签。&lt;/p&gt;

&lt;p&gt;*标签可以是任何内容，我们这里把他设置成了一个对象*，&lt;/p&gt;

&lt;p&gt;因为我们是把vlist2.xml的元素抽象出来成为一个类ViewHolder，用了setTag，这个标签就是ViewHolder实例化后对象的一个属性。我们之后对于ViewHolder实例化的对象holder的操作，都会因为java的引用机制而一直存活并改变convertView的内容，而不是每次都是去new一个。我们就这样达到的重用。&lt;/p&gt;

&lt;p&gt;Tag的作用就是设置标签，标签可以是任意玩意。
以及convertView是如何在程序中使代码运行变的效率的：利用缓存convertView尽可能少实例化同样结构体的对象；&lt;/p&gt;

&lt;p&gt;自己在写demo的时候，本来是想看滑动listview，item的加载情况。没想到，意外的发现了getView的重复调用的情况。&lt;/p&gt;

&lt;p&gt;在布局中将listview里高度设置成wrap_parent。计算父控件的高度所以造成了一种反复调用情况，从而次数不确定。&lt;/p&gt;

&lt;p&gt;当我们固定listview的高度时（fill_parent或直接固定高度），那么listview很容易就能计算出容器内可以显示多少行。但如果我们使用了“wrap_content”，只有在屏幕内控件完全加载后才知道到底能显示多少行数据时，ListView自身便会做一些尝试性计算。在源码中可以发现一些叫做onMeasure的方法，目测是做此用处(源码略显复杂，没读透)。
当listview计算出屏幕一共需要多少行后，如果listview自身高度不变，那么它的容纳的行数就不会变，使用getChildCount()可以得到它的最大行数。&lt;/p&gt;

&lt;p&gt;更深层次的解释为:
View在Draw的时候分成两个阶段：measure和layout，在measure阶段时主要就是为了计算两个参数：height和width。而且要注意的是，这是个递归的过程，从顶向下，DecorView开始依次调用自己子元素的measure。计算完成这两个参数后就开始layout，最后再是draw的调用。
对于ListView，当然每一个Item都会被调用measure方法，而在这个过程中getView和getCount会被调用，而且看用户的需求，可能会有很多次调用。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
